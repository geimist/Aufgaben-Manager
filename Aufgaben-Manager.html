<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='green' stroke-width='2'><rect x='2' y='2' width='20' height='20' rx='3' ry='3' fill='none' stroke='green' stroke-width='2'/><path d='M7 13l3 3 7-7' fill='none' stroke='green' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'/></svg>">
    <link rel="apple-touch-icon" sizes="152x152" href="https://raw.githubusercontent.com/geimist/Aufgaben-Manager/refs/heads/master/images/apple-touch-icon_152px.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/geimist/Aufgaben-Manager/refs/heads/master/images/apple-touch-icon_180px.png">
    <title>Aufgaben Manager</title>
    <style>
        :root {
            /* Light Theme Colors */
            --primary: #3498db;
            --secondary: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --dark: #34495e;
            --light: #ecf0f1;
            --gray: #95a5a6;

            /* Light Theme Backgrounds and Texts */
            --bg-color: #f5f7fa;
            --card-bg: white;
            --header-bg: white;
            --text-color: #333;
            --text-muted: #666;
            --border-color: #ddd;
            --hover-bg: #f5f5f5;
            --shadow: rgba(0, 0, 0, 0.1);
            --modal-bg: white;
            --status-bg: rgba(0, 0, 0, 0.5);
            --input-bg: white;
            --table-header-bg: #f8f9fa;
            --table-hover-bg: #f8f9fa;
            --burger-bg: white;
            --settings-bg: white;
            --filter-bg: #f8f9fa;
        }

        /* Dark Theme Override */
        [data-theme="dark"] {
            /* Dark Theme Colors */
            --primary: #5dade2;
            --secondary: #58d68d;
            --danger: #ec7063;
            --warning: #f7dc6f;
            --dark: #aab7b8;
            --light: #34495e;
            --gray: #5d6d7e;

            /* Dark Theme Backgrounds and Texts */
            --bg-color: #1a1a1a;
            --card-bg: #2d2d2d;
            --header-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --text-muted: #b0b0b0;
            --border-color: #404040;
            --hover-bg: #404040;
            --shadow: rgba(0, 0, 0, 0.3);
            --modal-bg: #2d2d2d;
            --status-bg: rgba(0, 0, 0, 0.7);
            --input-bg: #3d3d3d;
            --table-header-bg: #404040;
            --table-hover-bg: #404040;
            --burger-bg: #2d2d2d;
            --settings-bg: #2d2d2d;
            --filter-bg: #404040;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 30px;
            background-color: var(--header-bg);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        h1 {
            color: var(--dark);
            font-weight: 600;
        }
        
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }
        
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Burger Menu Styles */
        .burger-menu {
            position: relative;
            display: inline-block;
        }
        
        .burger-icon {
            font-size: 1.5em;
            cursor: pointer;
            padding: 10px;
            background: transparent;
            color: var(--dark);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
        }
        
        .burger-content {
            display: none;
            position: absolute;
            background-color: var(--burger-bg);
            min-width: 200px;
            box-shadow: 0 8px 16px var(--shadow);
            z-index: 1000;
            border-radius: 4px;
            padding: 10px 0;
            top: 100%;
            left: 0;
            margin-top: 5px;
        }
        
        .burger-content a {
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            color: var(--dark);
            font-weight: 500;
        }
        
        .burger-content a:hover {
            background-color: #f5f5f5;
            color: var(--primary);
        }
        
        /* Burger menu hover handling moved to JavaScript for better control */
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
        }

        tr:hover {
            background-color: var(--table-hover-bg);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background-color: var(--input-bg);
            color: var(--text-color);
        }

        input:focus, select:focus, textarea:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--status-bg);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--modal-bg);
            border-radius: 8px;
            padding: 30px;
            width: 500px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: var(--text-color);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .close {
            font-size: 24px;
            cursor: pointer;
        }
        
        .status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 10000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 80%;
            text-align: center;
            font-weight: 500;
            animation: slideInDown 0.3s ease-out;
        }

        @keyframes slideInDown {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .status.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            display: block;
        }
        
        .completed {
            text-decoration: line-through;
            color: var(--gray);
        }

        .event-completed {
            text-decoration: line-through;
            color: var(--gray);
        }

        .event-hidden {
            display: none;
        }

        .completed.hidden {
            display: none;
        }

        /* Eleganter Filter-Switch */
        .todo-filter {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: var(--filter-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .event-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 20px;
        }

        .event-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .event-filter-buttons {
            display: flex;
            gap: 10px;
        }

        .filter-left {
            flex: 1;
        }

        .filter-buttons {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 20px;
            background-color: #f0f0f0;
            color: var(--dark);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            user-select: none;
        }

        .filter-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .filter-btn.active {
            border-color: currentColor;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .filter-btn[data-filter="erledigt"].active {
            background-color: #95a5a6;
            color: white;
            border-color: #95a5a6;
        }

        .filter-btn[data-filter="anstehend"].active {
            background-color: #e67e22;
            color: white;
            border-color: #e67e22;
        }

        .filter-btn[data-filter="offen"].active {
            background-color: #27ae60;
            color: white;
            border-color: #27ae60;
        }

        .filter-btn[data-filter="ueberfaellig"].active {
            background-color: #e74c3c;
            color: white;
            border-color: #e74c3c;
        }

        .filter-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .todo-counts {
            font-size: 14px;
            color: var(--dark);
            font-weight: 500;
        }

        .pending-count {
            color: var(--primary);
        }

        .completed-count {
            color: var(--gray); /* graue Darstellung für erledigte statt grün */
        }

        .pending-urgent {
            color: #e67e22; /* orange für anstehend */
            font-weight: 500;
        }

        .pending-normal {
            color: #27ae60; /* grün für offen */
        }

        .pending-overdue {
            color: #e74c3c; /* rot für überfällig */
            font-weight: 600;
        }

        .filter-label {
            font-size: 14px;
            color: var(--dark);
            margin-right: 15px;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 25px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 25px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 19px;
            width: 19px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(25px);
        }

        .actions {
            display: flex;
            gap: 10px;
        }
        
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px 8px;
            margin: 0 1px;
            border-radius: 4px;
            transition: all 0.2s;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        
        .icon-btn:hover {
            background-color: rgba(0,0,0,0.05);
            transform: scale(1.1);
        }

        /* Sync Indicator Styles */
        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(52, 152, 219, 0.2);
            font-size: 12px;
            color: var(--primary);
            font-weight: 500;
        }

        .sync-status {
            font-size: 11px;
            white-space: nowrap;
        }

        .sync-status.synced {
            color: var(--secondary);
        }

        .sync-status.upload-needed {
            color: #e67e22;
        }

        .sync-status.download-needed {
            color: #3498db;
        }

        .sync-status.conflict {
            color: #e74c3c;
            font-weight: 600;
            animation: sync-pulse 1.5s ease-in-out infinite;
        }

        .sync-status.error {
            color: var(--danger);
        }

        .sync-btn {
            font-size: 14px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .sync-btn:hover {
            background-color: rgba(52, 152, 219, 0.2);
            transform: scale(1.1);
        }

        /* Konflikt-Modal Styles */
        .conflict-modal .modal-content {
            width: 400px;
        }
        
        /* Backup-Versionen Modal breiter machen */
        #backupVersionsModal .modal-content {
            width: 800px;
        }

        .conflict-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .conflict-option {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .conflict-option:hover {
            background-color: #f8f9fa;
            border-color: var(--primary);
        }

        @keyframes sync-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .settings-menu {
            position: relative;
            display: inline-block;
        }

        .settings-menu .icon-btn {
            font-size: 1.5em;
            cursor: pointer;
            padding: 10px;
            background: transparent;
            color: var(--dark);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            transition: all 0.3s;
        }

        .settings-menu .icon-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .settings-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background-color: var(--settings-bg);
            min-width: 200px;
            box-shadow: 0 8px 16px var(--shadow);
            z-index: 1000;
            border-radius: 4px;
            padding: 10px 0;
            margin-top: 5px;
        }

        .settings-content a {
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            color: var(--dark);
            font-weight: 500;
        }

        .settings-content a:hover {
            background-color: #f5f5f5;
            color: var(--primary);
        }
        
        .todo-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .todo-item {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 15px;
            margin-bottom: 10px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .todo-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .todo-item:before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: #e0e0e0;
            transition: background-color 0.2s;
        }
        
        .todo-item:hover:before {
            background-color: var(--primary);
        }
        
        .todo-content {
            flex: 1;
            margin-right: 20px;
            min-width: 0; /* Prevents flex item from overflowing */
        }
        
        .todo-main {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .todo-main strong {
            color: var(--dark);
            font-weight: 600;
        }
        
        .todo-main .todo-type {
            color: var(--primary);
            font-weight: 500;
            font-size: 1.2em;
        }
        
        .todo-date {
            font-size: 0.85em;
            margin-top: 6px;
            display: flex;
            align-items: center;
        }

        /* Deadline Urgency Colors */
        .deadline-overdue {
            color: #8b0000;
            font-weight: bold;
            background: linear-gradient(130deg, rgba(235, 77, 75, 0.1) 0%, rgba(255, 0, 0, 0.05) 100%);
            border-radius: 4px;
            padding: 2px 4px;
            animation: deadline-glow 2s ease-in-out infinite;
        }

        .deadline-critical {
            color: #8b0000;
            font-weight: bold;
        }

        .deadline-warning {
            color: #f39c12;
            font-weight: bold;
        }

        .deadline-soon {
            color: #f1c40f;
        }

        .deadline-normal {
            color: #27ae60;
        }

        .deadline-completed {
            color: #95a5a6;
        }

        @keyframes deadline-glow {
            0% {
                box-shadow: 0 0 0 0 rgba(235, 77, 75, 0.4);
                background: linear-gradient(130deg, rgba(235, 77, 75, 0.1) 0%, rgba(255, 0, 0, 0.05) 100%);
            }
            50% {
                box-shadow: 0 0 10px 3px rgba(235, 77, 75, 0.6);
                background: linear-gradient(130deg, rgba(235, 77, 75, 0.15) 0%, rgba(255, 0, 0, 0.08) 100%);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(235, 77, 75, 0.4);
                background: linear-gradient(130deg, rgba(235, 77, 75, 0.1) 0%, rgba(255, 0, 0, 0.05) 100%);
            }
        }
        
        
        .todo-actions {
            display: flex;
            align-items: flex-start;
            padding-top: 2px;
        }
        
        .todo-checkbox {
            width: 22px;
            height: 22px;
            min-width: 22px;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            outline: none;
            transition: all 0.2s;
            position: relative;
            margin-left: 12px;
            background-color: white;
            flex-shrink: 0;
        }
        
        .todo-checkbox:checked {
            background-color: var(--primary);
            border-color: var(--primary);
        }
        
        .todo-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .todo-source {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed var(--border-color);
            font-size: 0.85em;
            color: var(--text-muted);
        }
        
        .todo-description {
            margin: 6px 0;
            color: var(--text-muted);
            line-height: 1.5;
        }
        
        .todo-item.completed .todo-main,
        .todo-item.completed .todo-description {
            opacity: 0.7;
        }
        
        .todo-item.completed .todo-main strong {
            text-decoration: line-through;
        }
        
        .source-link {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
            padding: 4px 10px;
            border-radius: 4px;
            background-color: rgba(52, 152, 219, 0.1);
            display: inline-flex;
            align-items: center;
            transition: all 0.2s;
            font-size: 0.9em;
        }
        
        .source-link:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }
        
        .source-link::before {
            content: "🔗";
            margin-right: 5px;
        }
        
        .tasks-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .task-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            border-left: 4px solid var(--primary);
            overflow: hidden;
        }

        .task-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            min-height: 60px;
        }

        .task-main {
            flex: 1;
            margin-right: 20px;
            min-width: 0;
        }

        .task-title {
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 4px;
            display: block;
        }

        .task-event {
            font-size: 0.9em;
            color: var(--primary);
            display: block;
        }

        .task-actions {
            display: flex;
            gap: 8px;
        }

        .accordion-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 0.95em;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .accordion-toggle:hover {
            background-color: var(--hover-bg);
            color: var(--text-color);
        }

        .accordion-content {
            display: none;
            padding: 15px;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
        }

        .accordion-content.show {
            display: block;
        }

        /* Mobile Responsivität für Task-Layout */
        @media (max-width: 667px) {
            .task-row {
                flex-direction: column;
                gap: 10px;
            }

            .task-actions {
                align-self: flex-end;
                gap: 6px;
            }

            .icon-btn {
                width: 28px;
                height: 28px;
                font-size: 1em;
                padding: 3px 6px;
            }

            .accordion-toggle {
                margin-top: 8px;
                padding: 3px 8px;
                font-size: 0.9em;
            }
        }

        /* Password Toggle Button Styling */
        .password-toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 2px;
            border-radius: 4px;
            transition: all 0.3s;
            color: #666;
        }

        .password-toggle-btn:hover {
            color: #333;
            background-color: rgba(0, 0, 0, 0.1);
        }
        
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .event-suggestions {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            position: absolute;
            background: white;
            width: calc(100% - 20px);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .event-suggestion {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .event-suggestion:hover {
            background-color: #f0f0f0;
        }
        
        .event-input-container {
            position: relative;
        }
        
        .no-tasks-warning {
            background-color: var(--card-bg);
            border-left: 4px solid var(--warning);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .file-input {
            display: none;
        }
        
        /* Stil für das Datalist-Input */
        input[list] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input[list]:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        /* Export Reminder Banner Styles */
        .export-reminder {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0;
            min-width: 300px;
            max-width: 400px;
            z-index: 10000;
            display: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            animation: slideInFromRight 0.3s ease-out;
        }

        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .export-reminder-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .export-reminder-text {
            flex: 1;
            font-size: 14px;
            color: #333;
            font-weight: 500;
            line-height: 1.4;
            margin: 0;
            padding: 15px;
        }

        .export-reminder-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 10px;
        }

        .btn-reminder {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            text-align: center;
        }

        .btn-reminder:hover {
            transform: translateY(-1px);
        }

        .btn-reminder.btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-reminder.btn-primary:hover {
            background-color: #2980b9;
        }

        @media (max-width: 480px) {
            .export-reminder {
                left: 10px;
                right: 10px;
                bottom: 10px;
                min-width: auto;
            }

            .export-reminder-content {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }

            .export-reminder-actions {
                flex-direction: row;
                justify-content: center;
                width: 100%;
                padding: 10px 15px;
            }

            .btn-reminder {
                flex: 1;
                max-width: 120px;
            }

        }
    </style>
</head>
<body>
    <!-- Export Reminder Banner (Nicht-störend) -->
    <div id="exportReminder" class="export-reminder" style="display: none;">
        <div class="export-reminder-content">
            <p id="exportReminderText" class="export-reminder-text">Monatlicher Export empfohlen.</p>
            <div class="export-reminder-actions">
                <button id="exportReminderDismiss" class="btn-reminder">Schließen</button>
                <button id="exportReminderExport" class="btn-reminder btn-primary">Jetzt exportieren</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <div class="header-left">
                <div class="burger-menu">
                    <div class="burger-icon">☰</div>
                    <div class="burger-content">
                        <a href="#" data-tab="todos">To-Dos</a>
                        <a href="#" data-tab="events">Events</a>
                        <a href="#" data-tab="tasks">Tasks</a>
                    </div>
                </div>
                <h1 id="appTitle">Event-Task Manager</h1>
            </div>
            <div class="actions">
                <div id="syncIndicator" class="sync-indicator" style="display: none; align-items: center; gap: 10px; margin-right: 15px;">
                    <span id="syncStatus" class="sync-status">🔄 Sync Status</span>
                    <button id="manualSyncBtn" class="sync-btn icon-btn" title="Manueller Sync">🔄</button>
                </div>
                <div class="settings-menu">
                    <button class="icon-btn">⚙️</button>
                    <div class="settings-content">
                        <a href="#" id="importDbBtn">DB importieren</a>
                        <a href="#" id="exportDbBtn">DB exportieren</a>
                        <a href="#" id="serverConfigBtn">Server-Einstellungen</a>
                        <a href="#" id="backupVersionsBtn">Versionsexplorer</a>
                        <a href="#" id="uploadSyncBtn">Upload zum Server</a>
                        <a href="#" id="downloadSyncBtn">Download vom Server</a>
                        <a href="#" id="contactBtn">Kontakt</a>
                        <a href="#" id="toggleThemeBtn">🌙 Dark Theme</a>
                        <div id="versionInfo" style="margin-top: 10px; padding: 8px; border-top: 1px solid #ccc; font-size: 12px; color: #666; text-align: center;">
                            <a id="versionLink" href="#" target="_blank" style="color: inherit; text-decoration: none;">Version: <span id="versionNumber"></span></a>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <div id="status" class="status"></div>
        
        <div class="tab-content active" id="eventsTab">
             <div class="card">
                 <div class="event-header">
                     <h2>Events</h2>
                     <div class="event-actions">
                         <button id="addEventBtn" class="btn btn-secondary">Event hinzufügen</button>
                         <div class="event-filter-buttons">
                             <button type="button" class="filter-btn" data-filter="erledigt" id="filter-event-erledigt">0 Erledigt</button>
                         </div>
                     </div>
                 </div>
                 <div id="eventsTableContainer"></div>
             </div>
         </div>
        
        <div class="tab-content" id="todosTab">
            <div class="card">
                <h2>To-Dos für Events</h2>
                <div class="todo-filter">
                    <div class="filter-buttons">
                        <button type="button" class="filter-btn" data-filter="erledigt" id="filter-erledigt">0 Erledigt</button>
                        <button type="button" class="filter-btn active" data-filter="anstehend" id="filter-anstehend">0 Anstehend</button>
                        <button type="button" class="filter-btn" data-filter="offen" id="filter-offen">0 Offen</button>
                        <button type="button" class="filter-btn active" data-filter="ueberfaellig" id="filter-ueberfaellig">0 Überfällig</button>
                    </div>
                </div>
                <div id="todosContainer"></div>
            </div>
        </div>
        
        <div class="tab-content" id="tasksTab">
             <div class="card">
                 <h2>Tasks</h2>
                 <div class="task-header" style="display: flex; align-items: center; gap: 10px;">
                     <button id="addTaskBtn" class="btn btn-secondary" style="align-self: flex-start;">Task hinzufügen</button>
                     <input type="text" id="taskFilter" placeholder="Aufgaben filtern..." style="flex: 1; margin-bottom: 0;">
                 </div>
                 <div id="tasksContainer" class="tasks-grid"></div>
             </div>
         </div>
        
        <!-- Modals -->
        <div id="eventModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="eventModalTitle">Event hinzufügen</h2>
                    <span class="close">&times;</span>
                </div>
                <form id="eventForm">
                    <input type="hidden" id="eventId">
                    <div class="form-group event-input-container">
                        <label for="eventName">Event Name</label>
                        <input type="text" id="eventName" list="eventNameSuggestions" required autocomplete="off">
                        <datalist id="eventNameSuggestions">
                            <!-- Vorschläge werden dynamisch geladen -->
                        </datalist>
                    </div>
                    <div class="form-group">
                        <label for="eventDate">Datum</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label for="eventDescription">Beschreibung</label>
                        <textarea id="eventDescription" rows="3"></textarea>
                    </div>
                    <button type="submit" class="btn btn-primary">Speichern</button>
                </form>
            </div>
        </div>
        
        <div id="taskModal" class="modal">
             <div class="modal-content">
                 <div class="modal-header">
                     <h2 id="taskModalTitle"></h2>
                     <span class="close">&times;</span>
                 </div>
                 <form id="taskForm">
                     <input type="hidden" id="taskId">
                     <input type="hidden" id="recurrenceId">
                     <div class="form-group">
                         <label for="eventType">Ereignis</label>
                         <input type="text" id="eventType" list="eventTypeSuggestions" required>
                         <datalist id="eventTypeSuggestions">
                             <!-- Vorschläge werden dynamisch geladen -->
                         </datalist>
                     </div>
                     <div class="form-group">
                         <label for="taskType">Aufgabe</label>
                         <input type="text" id="taskType" required>
                     </div>
                     <div class="form-group">
                         <label for="taskDescription">Beschreibung</label>
                         <textarea id="taskDescription" rows="3"></textarea>
                     </div>
                     <div class="form-group">
                         <label for="range">Range</label>
                         <select id="range" required>
                             <option value="davor">davor</option>
                             <option value="am">am</option>
                             <option value="danach">danach</option>
                         </select>
                     </div>
                     <div class="form-group">
                         <label for="value">Wert</label>
                         <input type="number" step="any" id="value" required>
                     </div>
                     <div class="form-group">
                         <label for="unit">Einheit</label>
                         <select id="unit" required>
                             <option value="Tage">Tage</option>
                             <option value="Wochen">Wochen</option>
                             <option value="Monate">Monate</option>
                         </select>
                     </div>
                     <div class="form-group">
                         <label for="source">Source (URL oder Text)</label>
                         <input type="text" id="source">
                     </div>

                     <!-- NEUE FELDER FÜR WIEDERKEHRENDE TASKS -->
                     <div class="form-group">
                         <label for="isRecurring">
                             <input type="checkbox" id="isRecurring" style="width: auto; margin-right: 8px;">
                             Wiederkehrender Task
                         </label>
                     </div>
                     <div id="recurrenceFields" style="display: none;">
                         <h3 style="margin-top: 20px; margin-bottom: 10px; color: var(--primary);">Wiederholungseinstellungen</h3>

                         <div class="form-group">
                             <label for="recurrenceInterval">Alle</label>
                             <input type="number" id="recurrenceInterval" min="1" value="1" style="width: 60px;">
                             <select id="recurrenceUnit" style="width: auto;">
                                 <option value="days">Tage</option>
                                 <option value="weeks">Wochen</option>
                                 <option value="months" selected>Monate</option>
                                 <option value="years">Jahre</option>
                             </select>
                         </div>

                         <div class="form-group">
                             <label for="maxOccurrences">Maximale Häufigkeit</label>
                             <input type="number" id="maxOccurrences" min="1" placeholder="unbegrenzt lassen" style="width: 120px;">
                             <small style="color: #666;">Leer lassen für unbegrenzt (max. 2 Jahre)</small>
                         </div>

                         <div class="form-group">
                             <label for="endDate">Enddatum (optional)</label>
                             <input type="date" id="endDate">
                             <small style="color: #666;">Bis zu diesem Datum wiederholen</small>
                         </div>
                     </div>

                     <button type="submit" class="btn btn-primary">Speichern</button>
                 </form>
             </div>
         </div>
        
        <!-- Bestätigungs-Modal -->
        <div id="serverConfigModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <div style="flex: 1;">
                        <h2>Server-Einstellungen</h2>
                        <small style="color: #666; font-size: 12px; display: block; margin-top: 5px;">
                            Nutze einen Sync-Server um den Datenbestand auf mehreren Geräten synchron zu halten, eine Versionsverwaltung zu nutzen und Zugriff auf das Kontaktformular zu haben.
                        </small>
                    </div>
                    <span class="close">&times;</span>
                </div>
                <form id="serverConfigForm">
                    <div class="form-group">
                        <label for="serverUrl">Server-URL</label>
                        <input type="url" id="serverUrl" placeholder="https://example.com/sync.php">
                    </div>
                    <div class="form-group">
                        <label for="userUid">Benutzer-ID (UID)</label>
                        <input type="text" id="userUid" placeholder="deine eindeutige ID" required>
                        <small style="color: #666; font-size: 12px;">Eine eindeutige ID für deinen Account auf dem Server</small>
                    </div>
                    <div class="form-group">
                        <label for="deviceName">Geräte-Name</label>
                        <input type="text" id="deviceName" placeholder="z.B. Mein Arbeits-PC" style="width: calc(100% - 20px);">
                        <small style="color: #666; font-size: 12px;">Optionaler benutzerfreundlicher Name für dieses Gerät (leer lassen für automatische Erkennung)</small>
                        <div id="currentDeviceName" style="margin-top: 5px; font-size: 12px; color: #888;">
                            Aktueller Name: <span id="currentNameDisplay">wird geladen...</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="encryptionKey">Verschlüsselungs-Schlüssel</label>
                        <div class="password-input-container" style="position: relative;">
                            <input type="password" id="encryptionKey" placeholder="Optionaler Sicherheitsschlüssel" style="width: 100%; padding-right: 40px;">
                            <button type="button" id="toggleEncryptionKey" class="password-toggle-btn" title="Passwort ein-/ausblenden" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 16px; padding: 2px;">
                                👁️
                            </button>
                        </div>
                        <small style="color: #666; font-size: 12px;">Ein Schlüssel zum Verschlüsseln der Sync-Daten. Leer lassen für unverschlüsselte Synchronisation.</small>
                        <div id="keyHint" style="margin-top: 5px; font-size: 12px; color: #888; display: none;">
                            ⚠️ Änderungen des Schlüssels machen alte verschlüsselte Backups unzugänglich
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button type="submit" class="btn btn-primary">Speichern</button>
                        <button type="button" class="btn btn-outline" onclick="closeServerConfigModal()">Abbrechen</button>
                        <button type="button" class="btn btn-outline" onclick="resetToAutoDeviceName()" style="margin-left: 10px;" title="Zurück zu automatisch erkanntem Namen">Zurücksetzen</button>
                    </div>
                </form>
            </div>
        </div>

        <div id="backupVersionsModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Backup-Versionen wiederherstellen</h2>
                    <span class="close">&times;</span>
                </div>
                <div id="backupVersionsMessage" style="margin-bottom: 20px;">
                    Verfügbare Backup-Versionen vom Server. Wähle eine Version zum Wiederherstellen aus.<br>
                    <small style="color: #666;">Ältere Versionen werden automatisch gelöscht.</small>
                </div>
                <div id="versionsList" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                    <!-- Versionen werden hier geladen -->
                </div>
                <div style="text-align: center;">
                    <button id="closeVersionsBtn" class="btn btn-outline">Schließen</button>
                </div>
            </div>
        </div>

        <div id="confirmModal" class="modal">
              <div class="modal-content">
                  <div class="modal-header">
                      <h2 id="confirmModalTitle">Bestätigung</h2>
                      <span class="close" id="confirmModalClose">&times;</span>
                  </div>
                  <div id="confirmModalMessage" style="margin-bottom: 20px;">Möchtest du das wirklich tun?</div>
                  <div style="text-align: center;">
                      <button id="confirmBtn" class="btn btn-primary" style="margin-right: 10px;">Ja</button>
                      <button id="cancelBtn" class="btn btn-outline">Nein</button>
                  </div>
              </div>
          </div>

        <input type="file" id="fileInput" class="file-input" accept=".db,.sqlite,.sqlite3">
    </div>

    <div id="contactModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Kontakt</h2>
                <span class="close">&times;</span>
            </div>
            <div id="contactMessage" style="margin-bottom: 20px;">
                Du kannst mir eine Nachricht senden. Gib deinen Namen, deine E-Mail-Adresse und deine Nachricht ein.
            </div>
            <form id="contactForm">
                <div class="form-group">
                    <label for="contactName">Name</label>
                    <input type="text" id="contactName" required placeholder="Dein Name">
                </div>
                <div class="form-group">
                    <label for="contactEmail">E-Mail</label>
                    <input type="email" id="contactEmail" required placeholder="deine@email.de">
                </div>
                <div class="form-group">
                    <label for="contactMessage">Nachricht</label>
                    <textarea id="contactText" rows="5" required placeholder="Deine Nachricht hier..."></textarea>
                </div>
                <button type="submit" class="btn btn-primary">Nachricht senden</button>
                <button type="button" class="btn btn-outline" onclick="document.getElementById('contactModal').style.display = 'none';">Abbrechen</button>
            </form>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <script>
        // ============================
        // KONFIGURATION - HIER ANPASSEN
        // ============================

        // Manuell gepflegte Versionsnummer
        const APP_VERSION = "1.1.0";

        // GitHub-Link
        const GITHUB_LINK = "https://github.com/geimist/Aufgaben-Manager";

        // Anpassbare Dringlichkeit-Schwellenwerte (in Tagen)
        const DEADLINE_CONFIG = {
            critical: 7,    // Kritischer Zeitraum (< 7 Tage)
            warning: 14,    // Warning-Bereich (8-14 Tage)
            soon: 31        // Soon-Bereich (15-31 Tage)
        };

        // Anpassbare Begriffe (unvollständig)
        const TEXT_CONFIG = {
            appTitle: "Aufgaben Manager",
            eventsTab: "Ereignisse",
            todosTab: "Deadlines",
            tasksTab: "Aufgaben",
            eventsHeader: "",
            todosHeader: "",
            tasksHeader: "",
            addEventButton: "Ereignis hinzufügen",
            addTaskButton: "Aufgabe hinzufügen",
            importDbButton: "DB importieren",
            exportDbButton: "DB exportieren",
            manageTasksButton: "Aufgaben verwalten",
            noTasksWarning: "Keine passenden Aufgaben für dieses Ereignis gefunden",
            eventNameLabel: "Ereignis Name",
            eventDateLabel: "Datum",
            eventDescriptionLabel: "Beschreibung",
            eventTypeLabel: "Ereignis",
            taskTypeLabel: "Aufgabe",
            taskDescriptionLabel: "Beschreibung",
            rangeLabel: "Range",
            valueLabel: "Wert",
            unitLabel: "Einheit",
            sourceLabel: "Source (URL oder Text)",
            // Modale Titel
            addEventTitle: "Ereignis hinzufügen",
            editEventTitle: "Ereignis bearbeiten",
            addTaskTitle: "Aufgabe hinzufügen",
            editTaskTitle: "Aufgabe bearbeiten",
            // Button-Texte
            saveButton: "Speichern",
            cancelButton: "Abbrechen",
            deleteButton: "Löschen",
            duplicateButton: "Duplizieren",
            // Dropdown-Optionen
            rangeBefore: "davor",
            rangeOn: "am",
            rangeAfter: "danach",
            unitDays: "Tage",
            unitWeeks: "Wochen",
            unitMonths: "Monate",
            unitYears: "Jahre",
            // Bestätigungsmeldungen
            confirmDeleteEvent: "Möchtest du dieses Ereignis wirklich löschen?",
            confirmDeleteTask: "Möchtest du diese Aufgabe wirklich löschen?",
            // Statusmeldungen
            eventSaved: "Ereignis erfolgreich gespeichert",
            taskSaved: "Aufgabe erfolgreich gespeichert",
            eventDeleted: "Ereignis erfolgreich gelöscht",
            taskDeleted: "Aufgabe erfolgreich gelöscht",
            // Fehlermeldungen
            errorSavingEvent: "Fehler beim Speichern des Ereignises",
            errorSavingTask: "Fehler beim Speichern der Aufgabe",
            errorDeletingEvent: "Fehler beim Löschen des Ereignises",
            errorDeletingTask: "Fehler beim Löschen der Aufgabe"
        };
        
        // ============================
        // GLOBALE VARIABLEN
        // ============================

        let db;
        let SQL;
        let eventTypes = [];
        let currentTab = 'todos'; // Standard-Tab
        let activeFilters = ['anstehend', 'ueberfaellig']; // Aktive Filter für Todo-Anzeige (nur dringende als Standard)
        let allTodos = []; // Globale allTodos für Zählungen
        let hideCompletedEvents = true; // Filter für Event-Liste (true = erledigte Events ausblenden)

        // Deaktivierung für wiederholte Sync-Nachfragen (bei Ablehnung)
        let syncSuggestionDisabledUntil = null;
        const DISABLE_DURATION_MS = 5 * 60 * 1000; // 5 Minuten
        
        let todoCounts = {}; // Globale Zählungen für Filter-Buttons

        // ============================
        // THEME MANAGEMENT FUNCTIONS
        // ============================

        // Theme beim Laden anwenden
        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
        }

        // Theme umschalten
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);

            showStatus(`Theme zu ${newTheme === 'dark' ? 'Dunkel' : 'Hell'} gewechselt`, 'success');
        }

        // Theme-Präferenz laden und anwenden
        function loadThemePreference() {
            applySavedTheme();
            updateThemeButton();
        }

        // Theme-Button aktualisieren
        function updateThemeButton() {
            const button = document.getElementById('toggleThemeBtn');
            if (!button) return;

            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            if (currentTheme === 'dark') {
                button.innerHTML = '☀️ Hell';
                button.title = 'Zu hellem Theme wechseln';
            } else {
                button.innerHTML = '🌙 Dunkel';
                button.title = 'Zu dunklem Theme wechseln';
            }
        }
        
        // ============================
        // INITIALISIERUNG
        // ============================
        
        // DOM geladen
        document.addEventListener('DOMContentLoaded', init);
        
        function init() {
            // Theme beim Laden anwenden
            loadThemePreference();

            // Texte anwenden
            applyTextConfig();
            
            // Event-Listener für Burger-Menü
                document.querySelectorAll('.burger-content a').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const tab = e.target.dataset.tab;
                        switchTab(tab);
                    });
                });
    
                // Event-Listener für Filter-Switch
                setupTodoFilter();
            
            // Event-Listener für Buttons und Settings-Menü
            document.getElementById('importDbBtn').addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('fileInput').click();
            });

            // Event-Listener für Event-Filter-Button
            document.getElementById('filter-event-erledigt').addEventListener('click', toggleEventFilter);

            // Contact-Funktionalität
            document.getElementById('contactBtn').addEventListener('click', (e) => {
                e.preventDefault();
                openContactModal();
            });
            document.getElementById('contactForm').addEventListener('submit', sendContactForm);

            // Theme Toggle Funktionalität
            document.getElementById('toggleThemeBtn').addEventListener('click', (e) => {
                e.preventDefault();
                toggleTheme();
                updateThemeButton();
            });
            document.getElementById('exportDbBtn').addEventListener('click', (e) => {
                e.preventDefault();
                exportDatabase();
            });
            document.getElementById('fileInput').addEventListener('change', importDatabase);
            document.getElementById('addEventBtn').addEventListener('click', () => openEventModal());
            document.getElementById('addTaskBtn').addEventListener('click', () => openTaskModal());
            document.getElementById('taskFilter').addEventListener('input', function() {
                loadTasks(this.value);
            });

            // Server-Sync Event-Listener
            document.getElementById('serverConfigBtn').addEventListener('click', (e) => {
                e.preventDefault();
                openServerConfigModal();
            });
            document.getElementById('backupVersionsBtn').addEventListener('click', (e) => {
                e.preventDefault();
                openBackupVersionsModal();
            });
            document.getElementById('uploadSyncBtn').addEventListener('click', (e) => {
                e.preventDefault();
                uploadDatabaseToServer();
            });
            document.getElementById('downloadSyncBtn').addEventListener('click', (e) => {
                e.preventDefault();
                downloadDatabaseFromServer();
            });

            // Export Reminder Banner Event-Handler
            document.getElementById('exportReminderDismiss').addEventListener('click', () => {
                document.getElementById('exportReminder').style.display = 'none';
            });
            document.getElementById('exportReminderExport').addEventListener('click', () => {
                exportDatabase();
            });
            
            // Standard-Tab anzeigen
            switchTab(currentTab);

            // Burger-Menü-Event-Listener hinzufügen
            setupBurgerMenu();

            // Settings-Menü-Event-Listener hinzufügen
            setupSettingsMenu();

            // SYNK-STATUS: Page Visibility API - Serverstatus prüfen wenn Browser-Tab wieder aktiv wird
            if (typeof document.hidden !== 'undefined') {
                document.addEventListener('visibilitychange', function() {
                    if (!document.hidden) {
                        // Tab wurde wieder aktiv - Serverstatus prüfen (falls konfiguriert)
                        const config = getServerConfig();
                        if (config) {
                            updateSyncIndicator();
                        }
                    }
                });
            }
        }

        // Tab wechseln
        function switchTab(tabName) {
            // Alle Tabs ausblenden
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Gewählten Tab anzeigen
            const targetTabElement = document.getElementById(tabName + 'Tab');
            if (targetTabElement) {
                targetTabElement.classList.add('active');
                currentTab = tabName;
            } else {
                console.error('Tab-Element nicht gefunden:', tabName + 'Tab');
            }

            // Daten für den Tab laden
            if (tabName === 'events') {
                // Events lädt automatisch auch Todos zur Zählung
                loadEvents();
                loadTodos(); // Erforderlich für allTodos initialisierung
            } else if (tabName === 'todos') {
                loadTodos();
                loadEvents(); // Aktualisiert Event-Anzeige nach Todos reloaded
            } else if (tabName === 'tasks') {
                loadTasks();
            }

            // SYNK-STATUS: Nach Tab-Wechsel automatisch Serverstatus prüfen (falls konfiguriert)
            if (getServerConfig()) {
                updateSyncIndicator();
            }
        }

        // Select-Optionen initialisieren
        function initializeSelects() {
            const rangeSelect = document.getElementById('range');
            if (rangeSelect) {
                rangeSelect.innerHTML = `
                    <option value="davor">${TEXT_CONFIG.rangeBefore}</option>
                    <option value="am">${TEXT_CONFIG.rangeOn}</option>
                    <option value="danach">${TEXT_CONFIG.rangeAfter}</option>
                `;
            }
            
            const unitSelect = document.getElementById('unit');
            if (unitSelect) {
                unitSelect.innerHTML = `
                    <option value="Tage">${TEXT_CONFIG.unitDays}</option>
                    <option value="Wochen">${TEXT_CONFIG.unitWeeks}</option>
                    <option value="Monate">${TEXT_CONFIG.unitMonths}</option>
                `;
            }
        }

        // Event-Listener für Formulare
        document.getElementById('eventForm').addEventListener('submit', saveEvent);
        document.getElementById('taskForm').addEventListener('submit', saveTask);
        
        // Selects initialisieren
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSelects);
        } else {
            initializeSelects();
        }

        // Event-Listener für Modals
        document.querySelectorAll('.close').forEach(close => {
            close.addEventListener('click', () => {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.style.display = 'none';
                });
            });
        });
        
        // Klick außerhalb des Modals schließt es
        window.addEventListener('click', (e) => {
            document.querySelectorAll('.modal').forEach(modal => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // Vorschlagsliste ausblenden, wenn woanders hingeklickt wird
            if (!e.target.matches('#eventName')) {
                // note: element "eventSuggestions" nicht vorhanden in original; safe check:
                const el = document.getElementById('eventSuggestions');
                if (el) el.style.display = 'none';
            }
        });
        
        // Automatisch Datenbank initialisieren
        initializeDatabase().then(() => {
            // Sync-Indicator initialisieren nach erfolgreicher DB-Initialisierung
            updateSyncIndicator();

            // **FIXED**: Kontakt-Button-Sichtbarkeit NACH erfolgreicher DB-Initialisierung aktualisieren
            updateContactVisibility();

            // Event-Listener für Event-Name-Eingabe erst nach erfolgreicher Initialisierung
            const eventNameInput = document.getElementById('eventName');
            if (eventNameInput) {
                eventNameInput.addEventListener('input', setupEventInput);
                eventNameInput.addEventListener('focus', () => loadEventTypes());
            }

            // Event-Filter-Präferenz laden
            loadEventFilterPreference();
        });

            // Event-Listener für EventType-Feld-Vorschläge
            const eventTypeInput = document.getElementById('eventType');
            if (eventTypeInput) {
                eventTypeInput.addEventListener('focus', () => loadEventTypes());
            }
        // Burger-Menü mit verbesserter Steuerung einrichten
        function setupBurgerMenu() {
            const burgerMenu = document.querySelector('.burger-menu');
            const burgerContent = document.querySelector('.burger-content');
            let hideTimeout;

            if (!burgerMenu || !burgerContent) return;

            // Mouseenter-Event: Menü sofort anzeigen
            burgerMenu.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
                burgerContent.style.display = 'block';
            });

            // Mouseleave-Event: Menü mit Verzögerung ausblenden
            burgerMenu.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    burgerContent.style.display = 'none';
                }, 300); // 300ms Verzögerung
            });

            // Zusätzlich: Verhindere Schließen wenn Maus über dem Menü-Inhalt ist
            burgerContent.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
            });

            burgerContent.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    burgerContent.style.display = 'none';
                }, 300); // 300ms Verzögerung
            });

            // Click-Outside-Handling: Schließe Menü bei Klick außerhalb
            document.addEventListener('click', (e) => {
                if (!burgerMenu.contains(e.target)) {
                    clearTimeout(hideTimeout);
                    burgerContent.style.display = 'none';
                }
            });
        }

        // Settings-Menü mit verbesserter Steuerung einrichten
        function setupSettingsMenu() {
            const settingsMenu = document.querySelector('.settings-menu');
            const settingsContent = document.querySelector('.settings-content');
            let hideTimeout;

            if (!settingsMenu || !settingsContent) return;

            // Mouseenter-Event: Menü sofort anzeigen
            settingsMenu.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
                settingsContent.style.display = 'block';

                // SYNK-STATUS: Serverstatus beim Öffnen des Settings-Menüs aktualisieren
            //    const config = getServerConfig();
            //    if (config) {
            //        updateSyncIndicator();
            //    }
            });

            // Mouseleave-Event: Menü mit Verzögerung ausblenden
            settingsMenu.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    settingsContent.style.display = 'none';
                }, 300); // 300ms Verzögerung
            });

            // Zusätzlich: Verhindere Schließen wenn Maus über dem Menü-Inhalt ist
            settingsContent.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
            });

            settingsContent.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    settingsContent.style.display = 'none';
                }, 300); // 300ms Verzögerung
            });

            // Click-Outside-Handling: Schließe Menü bei Klick außerhalb
            document.addEventListener('click', (e) => {
                if (!settingsMenu.contains(e.target)) {
                    clearTimeout(hideTimeout);
                    settingsContent.style.display = 'none';
                }
            });
        }

        // Konfigurierte Texte anwenden
        function applyTextConfig() {
            document.getElementById('appTitle').textContent = TEXT_CONFIG.appTitle;

            // Version im Settings-Menü setzen
            document.getElementById('versionNumber').textContent = APP_VERSION;

            // GitHub-Link für Version-Info setzen
            const versionLink = document.getElementById('versionLink');
            if (versionLink) {
                versionLink.href = GITHUB_LINK;
            }

            // Burger-Menü Texte aktualisieren - VERBESSERT: Verwende textContent statt innerHTML um data-attributs nicht zu zerstören
            const burgerLinks = document.querySelectorAll('.burger-content a');
            burgerLinks.forEach(link => {
                const tabType = link.dataset.tab;
                let text = '';
                switch(tabType) {
                    case 'todos':
                        text = TEXT_CONFIG.todosTab;
                        link.style.fontWeight = 'bold'; // Fettdruck über CSS statt HTML
                        break;
                    case 'events':
                        text = TEXT_CONFIG.eventsTab;
                        break;
                    case 'tasks':
                        text = TEXT_CONFIG.tasksTab;
                        break;
                }
                link.textContent = text;
            });

            document.querySelector('#eventsTab h2').textContent = TEXT_CONFIG.eventsHeader;
            document.querySelector('#todosTab h2').textContent = TEXT_CONFIG.todosHeader;
            document.querySelector('#tasksTab h2').textContent = TEXT_CONFIG.tasksHeader;
            document.getElementById('addEventBtn').textContent = TEXT_CONFIG.addEventButton;
            document.getElementById('addTaskBtn').textContent = TEXT_CONFIG.addTaskButton;
            document.getElementById('importDbBtn').textContent = TEXT_CONFIG.importDbButton;
            document.getElementById('exportDbBtn').textContent = TEXT_CONFIG.exportDbButton;
            
            // Formular-Labels
            document.querySelector('label[for="eventName"]').textContent = TEXT_CONFIG.eventNameLabel;
            document.querySelector('label[for="eventDate"]').textContent = TEXT_CONFIG.eventDateLabel;
            document.querySelector('label[for="eventDescription"]').textContent = TEXT_CONFIG.eventDescriptionLabel;
            document.querySelector('label[for="eventType"]').textContent = TEXT_CONFIG.eventTypeLabel;
            document.querySelector('label[for="taskType"]').textContent = TEXT_CONFIG.taskTypeLabel;
            document.querySelector('label[for="taskDescription"]').textContent = TEXT_CONFIG.taskDescriptionLabel;
            document.querySelector('label[for="range"]').textContent = TEXT_CONFIG.rangeLabel;
            document.querySelector('label[for="value"]').textContent = TEXT_CONFIG.valueLabel;
            document.querySelector('label[for="unit"]').textContent = TEXT_CONFIG.unitLabel;
            document.querySelector('label[for="source"]').textContent = TEXT_CONFIG.sourceLabel;
        }
        
        // Datenbank initialisieren
        async function initializeDatabase() {
            try {
                // SQL.js initialisieren
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
                
                // Prüfen, ob eine Datenbank im localStorage gespeichert ist
                const savedDb = localStorage.getItem('todoManagerDB');
                
                if (savedDb) {
                    // Vorhandene Datenbank laden
                    const arrayBuffer = base64ToArrayBuffer(savedDb);
                    db = new SQL.Database(new Uint8Array(arrayBuffer));
                    // Meta-Daten für lokale Änderungswiederherstellung laden
                    let existingLastLocalChange = null;
                    let existingLastSyncTime = null;
                    try {
                        const localChangeResult = db.exec(`
                            SELECT value FROM metadata WHERE key = 'last_local_change'
                        `);
                        existingLastLocalChange = localChangeResult.length > 0 ? localChangeResult[0].values[0][0] : null;

                        const syncResult = db.exec(`
                            SELECT value FROM metadata WHERE key = 'last_sync_time'
                        `);
                        existingLastSyncTime = syncResult.length > 0 ? syncResult[0].values[0][0] : null;
                    } catch (e) {
                        console.warn('Debugge beim Laden von Meta-Daten:', e.message);
                    }

                    // FIX: Nach Reload lokale Änderungen korrekt wiederherstellen
                    if (existingLastLocalChange && existingLastSyncTime) {
                        // Wenn vorhanden prüfen ob last_local_change nicht korrekt aktualisiert wurde
                        try {
                            const storedChange = new Date(existingLastLocalChange);
                            const storedSync = new Date(existingLastSyncTime);

                            // Falls nach Reload der lokale Change nicht richtig wiedergegeben wird
                            // erzwinge eine Korrektur basierend auf localStorage-Änderung
                            const now = new Date();
                            now.setMinutes(now.getMinutes() - 1); // Toleranz für Timing-Abweichungen

                            if (storedChange <= storedSync) {
                                // Prüfe localStorage für Änderungen nach letztem Sync
                                const dbModified = localStorage.getItem('todoManagerDB_modified');

                                if (dbModified) {
                                    const modifiedTime = new Date(dbModified);
                                    if (modifiedTime > storedSync) {
                                        
                                        db.run(`
                                            INSERT OR REPLACE INTO metadata (key, value, updated_at)
                                            VALUES ('last_local_change', ?, datetime('now'))
                                        `, [dbModified]);

                                        existingLastLocalChange = dbModified;
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('Fehler bei der Wiederherstellung lokaler Änderungen:', e.message);
                        }
                    }

                    showStatus('Datenbank erfolgreich geladen', 'success');

                    // Auf vorhandener Datenbank: Tabellen sicherstellen (Migrationspfad)
                    createTablesIfNeeded();
                } else {
                    // Neue Datenbank erstellen
                    db = new SQL.Database();
                    createTablesIfNeeded();
                    showStatus('Neue Datenbank erstellt', 'success');
                }
                
                // Event-Types für Vorschläge laden
                loadEventTypes();
                
                // Daten für aktuellen Tab laden
                if (currentTab === 'events') {
                    loadEvents();
                } else if (currentTab === 'todos') {
                    loadTodos();
                } else if (currentTab === 'tasks') {
                    loadTasks();
                }

                // Export-Reminder prüfen und anzeigen
                checkAndShowExportReminder();

            } catch (error) {
                console.error('Fehler bei der Datenbankinitialisierung:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }

        // Export-Reminder prüfen und anzeigen
        function checkAndShowExportReminder() {
            if (!db) {
                console.warn('Datenbank nicht verfügbar für Export-Reminder');
                return;
            }

            try {
                // Letztes Export-Datum aus Metadata laden
                const result = db.exec(`
                    SELECT value, updated_at
                    FROM metadata
                    WHERE key = 'last_export_date'
                `);

                let shouldShowReminder = false;
                let daysSinceLastExport = 0;

                if (result.length > 0 && result[0].values.length > 0) {
                    const [lastExportDateStr] = result[0].values[0];
                    if (lastExportDateStr) {
                        const lastExport = new Date(lastExportDateStr);
                        const now = new Date();

                        // Tage seit letztem Export berechnen
                        const timeDiff = now.getTime() - lastExport.getTime();
                        daysSinceLastExport = Math.floor(timeDiff / (1000 * 3600 * 24));

                        // Reminder anzeigen wenn länger als 30 Tage (Variante B: permanent erinnern)
                        shouldShowReminder = daysSinceLastExport >= 30;
                    } else {
                        // Kein letztes Export-Datum vorhanden - Erstes Mal
                        shouldShowReminder = false;
                    }
                } else {
                    // Kein Metadaten-Eintrag - erstmalig, keine Erinnerung
                    shouldShowReminder = false;
                }

                // Banner anzeigen oder ausblenden
                const reminderElement = document.getElementById('exportReminder');
                const textElement = document.getElementById('exportReminderText');

                if (shouldShowReminder && reminderElement && textElement) {
                    // Text aktualisieren mit genauen Tagen
                    textElement.textContent = `Letzter Export vor ${daysSinceLastExport} Tagen. Monatlicher Export empfohlen.`;

                    // Banner sichtbar machen
                    reminderElement.style.display = 'block';
                } else if (reminderElement) {
                    // Banner ausblenden
                    reminderElement.style.display = 'none';
                }

            } catch (error) {
                console.error('Fehler beim Prüfen des Export-Reminders:', error);
            }
        }

        // Letztes Export-Datum aktualisieren
        function updateLastExportDate() {
            if (!db) {
                console.warn('Datenbank nicht verfügbar für Update Export-Datum');
                return;
            }

            try {
                const today = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD

                db.run(`
                    INSERT OR REPLACE INTO metadata (key, value, updated_at)
                    VALUES ('last_export_date', ?, datetime('now'))
                `, [today]);

                saveDatabase();
            } catch (error) {
                console.error('Fehler beim Aktualisieren des Export-Datums:', error);
            }
        }

        // Base64 zu ArrayBuffer konvertieren
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // ArrayBuffer zu Base64 konvertieren
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        // Datenbank speichern - mit Kontrolle über lokale Änderungsverfolgung
        function saveDatabase(updateLocalChange = false) {
            if (!db) return;

            try {
                const data = db.export();
                const base64 = arrayBufferToBase64(data);
                localStorage.setItem('todoManagerDB', base64);

                // Lokale Änderungen nur bei echten Datenänderungen tracken (nicht bei Reloads)
                if (updateLocalChange) {
                    const now = new Date().toISOString();

                    // FIX: Auch im localStorage den Modifikationszeitpunkt speichern
                    localStorage.setItem('todoManagerDB_modified', now);

                    db.run(`
                        INSERT OR REPLACE INTO metadata (key, value, updated_at)
                        VALUES ('last_local_change', ?, datetime('now'))
                    `, [now]);
                    
                } else {
                    
                }
            } catch (error) {
                console.error('Fehler beim Speichern der Datenbank:', error);
                showStatus('Fehler beim Speichern: ' + error.message, 'error');
            }
        }
        
        // Datenbank importieren
        async function importDatabase(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                db = new SQL.Database(new Uint8Array(arrayBuffer));
                
                // Datenbank speichern
                saveDatabase();
                
                // Event-Types für Vorschläge laden
                loadEventTypes();

                // Event-Filter-Präferenz laden
                console.log('Initialisierung: Starte loadEventFilterPreference');
                loadEventFilterPreference();
                console.log('Initialisierung: loadEventFilterPreference abgeschlossen');

                // Daten für aktuellen Tab laden
                if (currentTab === 'events') {
                    loadTodos(); // Zuerst Todos laden für allTodos
                    loadEvents(); // Dann Events mit vollständigen Daten
                } else if (currentTab === 'todos') {
                    loadTodos();
                } else if (currentTab === 'tasks') {
                    loadTasks();
                }
                
                showStatus('Datenbank erfolgreich importiert', 'success');
                
                // File Input zurücksetzen
                event.target.value = '';
                
            } catch (error) {
                console.error('Fehler beim Importieren der Datenbank:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }
        
        // Datenbank exportieren
        function exportDatabase() {
            if (!db) {
                showStatus('Keine Datenbank zum Exportieren vorhanden', 'error');
                return;
            }
            
            try {
                const data = db.export();
                const blob = new Blob([data], { type: 'application/x-sqlite3' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ToDoManager.db';
                a.click();
                
                URL.revokeObjectURL(url);
                // Letztes Export-Datum aktualisieren
                updateLastExportDate();

                // Export-Reminder neu prüfen
                checkAndShowExportReminder();

                showStatus('Datenbank erfolgreich exportiert', 'success');

            } catch (error) {
                console.error('Fehler beim Exportieren der Datenbank:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }
        
        // Event-Input-Änderungen überwachen
        function setupEventInput() {
            if (!db) {
                console.error('Datenbank nicht initialisiert');
                return;
            }
            
            const input = document.getElementById('eventName');
            if (!input) return;
            
            // Initialen Wert setzen, falls im Bearbeitungsmodus
            if (currentEventId) {
                try {
                    const result = db.exec('SELECT event FROM events WHERE id = ?', [currentEventId]);
                    if (result.length > 0 && result[0].values.length > 0) {
                        input.value = result[0].values[0][0];
                    }
                } catch (error) {
                    console.error('Fehler beim Laden des Event-Namens:', error);
                }
            }
        }
        
        // Event-Types und Task-Types für Vorschläge laden
        function loadEventTypes() {
            if (!db) {
                console.error('Datenbank nicht initialisiert');
                return;
            }
            
            try {
                // Lade vorhandene Event-Types
                let eventTypesResult;
                try {
                    eventTypesResult = db.exec('SELECT DISTINCT event FROM events');
                    if (eventTypesResult.length > 0) {
                        eventTypes = eventTypesResult[0].values.map(row => row[0]);
                    }
                } catch (e) {
                    console.warn('Konnte Event-Types nicht laden:', e.message);
                }
                
                // Lade vorhandene Event-Types für Vorschläge
                try {
                    const eventTypesResult = db.exec('SELECT DISTINCT event_type FROM tasks');
                    if (eventTypesResult.length > 0) {
                        const eventTypes = eventTypesResult[0].values.map(row => row[0]);
                        const suggestionsList = document.getElementById('eventNameSuggestions');
                        if (!suggestionsList) return;
                        
                        suggestionsList.innerHTML = ''; // Bestehende Vorschläge leeren
                        
                        // Füge jeden eindeutigen Event-Type als Option hinzu
                        const uniqueEventTypes = [...new Set(eventTypes)]; // Doppelte entfernen
                        uniqueEventTypes.forEach(type => {
                            if (type && type.trim() !== '') {
                                const option = document.createElement('option');
                                option.value = type;
                                suggestionsList.appendChild(option);
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Konnte Task-Types nicht laden:', e.message);
                }
                // Lade vorhandene Event-Namen für EventType-Feld (aus events-Tabelle)
                try {
                    const eventNamesResult = db.exec('SELECT DISTINCT event FROM events');
                    if (eventNamesResult.length > 0) {
                        const eventNames = eventNamesResult[0].values.map(row => row[0]);
                        const suggestionsList = document.getElementById('eventTypeSuggestions');
                        if (!suggestionsList) return;

                        suggestionsList.innerHTML = ''; // Bestehende Vorschläge leeren

                        // Füge jeden eindeutigen Event-Namen als Option hinzu
                        const uniqueEventNames = [...new Set(eventNames)]; // Doppelte entfernen
                        uniqueEventNames.forEach(eventName => {
                            if (eventName && eventName.trim() !== '') {
                                const option = document.createElement('option');
                                option.value = eventName;
                                suggestionsList.appendChild(option);
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Konnte Event-Namen nicht laden:', e.message);
                }
            } catch (error) {
                console.error('Fehler in loadEventTypes:', error);
            }
        }
        
        // Tabellen erstellen, falls nicht vorhanden
        function createTablesIfNeeded() {
            // Tabelle für Tasks (mit Beschreibungsfeld)
            db.run(`
                CREATE TABLE IF NOT EXISTS tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_type TEXT,
                    task_type TEXT,
                    description TEXT,
                    range TEXT,
                    value REAL,
                    unit TEXT,
                    source TEXT
                )
            `);

            // Tabelle für Events
            db.run(`
                CREATE TABLE IF NOT EXISTS events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event TEXT,
                    date DATE,
                    description TEXT
                )
            `);

            // MIGRATION: Prüfe und erstelle completed_tasks Tabelle mit Schema-Migration
            migrateCompletedTasksTable();

            // NEUE Tabelle für Wiederholungsregeln
            db.run(`
                CREATE TABLE IF NOT EXISTS task_recurrences (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id INTEGER NOT NULL,
                    is_active BOOLEAN DEFAULT 1,
                    interval_value INTEGER NOT NULL DEFAULT 1,
                    interval_unit TEXT NOT NULL DEFAULT 'months',
                    max_occurrences INTEGER DEFAULT 0,        -- 0 = unbegrenzt
                    end_date DATE,                            -- Optional: festes Enddatum
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
                    UNIQUE (task_id)                          -- Nur eine Recurrence pro Task
                )
            `);

            // NEUE Tabelle für ICS-Kalenderexporte
            db.run(`
                CREATE TABLE IF NOT EXISTS calendar_todos (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    event_id INTEGER,
                    task_id INTEGER,
                    title TEXT NOT NULL,
                    start_date DATE,
                    description TEXT,
                    exported_at DATETIME,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

                    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE,
                    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
                )
            `);

            // Metadata-Tabelle für Export-Erinnerungen und Server-Konfiguration
            db.run(`
                CREATE TABLE IF NOT EXISTS metadata (
                    key TEXT PRIMARY KEY,
                    value TEXT,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // Index für schnellere Abfragen
            db.run(`
                CREATE INDEX IF NOT EXISTS idx_calendar_todos_event_task
                ON calendar_todos(event_id, task_id)
            `);
            db.run(`
                CREATE INDEX IF NOT EXISTS idx_calendar_todos_uuid
                ON calendar_todos(uuid)
            `);

            // Datenbank speichern
            saveDatabase();
        }

        // Schema-Migration für completed_tasks Tabelle
        function migrateCompletedTasksTable() {
            try {

                // Prüfe, ob completed_tasks Tabelle existiert
                const tableExists = db.exec(`
                    SELECT name FROM sqlite_master
                    WHERE type='table' AND name='completed_tasks'
                `);

                if (tableExists.length === 0) {
                    // Neue Tabelle mit korrektem Schema erstellen
                    db.run(`
                        CREATE TABLE completed_tasks (
                            task_id INTEGER,
                            event_id INTEGER,
                            completed BOOLEAN DEFAULT 0,
                            completed_at DATETIME,
                            occurrence_date DATE,        -- Optional: Für wiederkehrende Instanzen
                            recurrence_id INTEGER,       -- Optional: Referenz auf Recurrence
                            PRIMARY KEY (task_id, event_id, occurrence_date),
                            FOREIGN KEY (task_id) REFERENCES tasks(id),
                            FOREIGN KEY (event_id) REFERENCES events(id)
                        )
                    `);
                    return;
                }

                // Prüfe, ob occurrence_date Spalte existiert
                const columnExists = db.exec(`
                    PRAGMA table_info(completed_tasks)
                `);

                let hasOccurrenceDate = false;
                let hasRecurrenceId = false;

                if (columnExists.length > 0) {
                    const columns = columnExists[0].values;
                    for (let column of columns) {
                        const columnName = column[1]; // Name ist bei Index 1
                        if (columnName === 'occurrence_date') hasOccurrenceDate = true;
                        if (columnName === 'recurrence_id') hasRecurrenceId = true;
                    }
                }


                if (!hasOccurrenceDate || !hasRecurrenceId) {
                    // Backup der bestehenden Daten
                    const existingData = db.exec('SELECT * FROM completed_tasks');

                    // Lösche alte Tabelle
                    db.run('DROP TABLE completed_tasks');

                    // Erstelle neue Tabelle mit korrektem Schema
                    db.run(`
                        CREATE TABLE completed_tasks (
                            task_id INTEGER,
                            event_id INTEGER,
                            completed BOOLEAN DEFAULT 0,
                            completed_at DATETIME,
                            occurrence_date DATE,        -- Optional: Für wiederkehrende Instanzen
                            recurrence_id INTEGER,       -- Optional: Referenz auf Recurrence
                            PRIMARY KEY (task_id, event_id, occurrence_date),
                            FOREIGN KEY (task_id) REFERENCES tasks(id),
                            FOREIGN KEY (event_id) REFERENCES events(id)
                        )
                    `);

                    // Migriere bestehende Daten (occurrence_date = NULL für alte Einträge)
                    if (existingData.length > 0 && existingData[0].values.length > 0) {
                        for (let row of existingData[0].values) {
                            const [taskId, eventId, completed, completedAt] = row;
                            db.run(`
                                INSERT INTO completed_tasks
                                (task_id, event_id, completed, completed_at, occurrence_date, recurrence_id)
                                VALUES (?, ?, ?, ?, NULL, NULL)
                            `, [taskId, eventId, completed, completedAt]);
                        }
                    }

                    showStatus('Datenbank-Schema erfolgreich aktualisiert', 'success');
                } else {
                }

            } catch (error) {
                console.error('❌ Fehler bei Schema-Migration:', error);
                showStatus('Warnung: Schema-Migration fehlgeschlagen: ' + error.message, 'warning');

                // Fallback: Versuche Tabelle trotzdem zu erstellen
                try {
                    db.run(`
                        CREATE TABLE IF NOT EXISTS completed_tasks (
                            task_id INTEGER,
                            event_id INTEGER,
                            completed BOOLEAN DEFAULT 0,
                            completed_at DATETIME,
                            occurrence_date DATE,
                            recurrence_id INTEGER,
                            PRIMARY KEY (task_id, event_id, occurrence_date),
                            FOREIGN KEY (task_id) REFERENCES tasks(id),
                            FOREIGN KEY (event_id) REFERENCES events(id)
                        )
                    `);
                } catch (fallbackError) {
                    console.error('❌ Auch Fallback fehlgeschlagen:', fallbackError);
                }
            }
        }
        
        // Hilfsfunktion: Prüft, ob alle ToDos eines Events erledigt sind
        function isEventCompleted(eventId) {
            if (!db || !allTodos) {
                return false;
            }

            try {
                // Verwende globale allTodos Variable
                const globalAllTodos = window.allTodos || allTodos;

                // Alle ToDos dieses Events aus generierter Liste filtern
                const eventTodos = globalAllTodos.filter(todo =>
                    todo.eventId === eventId && todo.type === 'task'
                );

                if (eventTodos.length === 0) {
                    return false; // Keine ToDos = nicht "completed"
                }

                // Prüfen, ob alle ToDos erledigt sind
                const unfinishedTodos = eventTodos.filter(todo => !todo.completed);

                return unfinishedTodos.length === 0;
            } catch (error) {
                console.error('Fehler beim Prüfen des Event-Status:', error);
                return false;
            }
        }

        // Event-Filter anwenden
        function applyEventFilter() {
            if (!db) return;

            const eventRows = document.querySelectorAll('#eventsTableContainer tr');
            eventRows.forEach(row => {
                if (row.classList.contains('event-completed')) {
                    if (hideCompletedEvents) {
                        row.classList.add('event-hidden');
                    } else {
                        row.classList.remove('event-hidden');
                    }
                }
            });

            updateEventFilterButtonStates();
        }

        // Event-Filter umschalten
        function toggleEventFilter() {
            hideCompletedEvents = !hideCompletedEvents;
            applyEventFilter();
            saveEventFilterPreference();
        }

        // Event-Filter-Button-Zustände aktualisieren
        function updateEventFilterButtonStates() {
            const button = document.getElementById('filter-event-erledigt');

            if (button) {
                // Entferne zuerst alle Zustände
                button.classList.remove('active');

                // Setze den korrekten Zustand
                if (!hideCompletedEvents) {
                    button.classList.add('active');
                }

                // Anzahl der erledigten Events aktualisieren
                updateEventCompletedCount();
            }
        }

        // Hilfsfunktion: Prüft, ob ein Todo exportiert wurde
        function isTodoExported(taskId, eventId, occurrenceDate) {
            if (!db) {
                return false;
            }

            try {
                const result = db.exec(`
                    SELECT id FROM calendar_todos
                    WHERE task_id = ? AND event_id = ? AND start_date = ?
                `, [taskId, eventId, occurrenceDate]);

                return result.length > 0 && result[0].values.length > 0;
            } catch (error) {
                console.error('Fehler beim Prüfen des Export-Status:', error);
                return false;
            }
        }

        // Event-Filter-Präferenz speichern
        function saveEventFilterPreference() {
            if (!db) return;

            try {
                db.run(`
                    INSERT OR REPLACE INTO metadata (key, value, updated_at)
                    VALUES ('hide_completed_events', ?, datetime('now'))
                `, [hideCompletedEvents ? '1' : '0']);
                saveDatabase();
            } catch (error) {
                console.error('Fehler beim Speichern der Event-Filter-Präferenz:', error);
            }
        }

        // Event-Filter-Präferenz laden
        function loadEventFilterPreference() {
            if (!db) return;

            try {
                const result = db.exec(`
                    SELECT value FROM metadata WHERE key = 'hide_completed_events'
                `);
                if (result.length > 0 && result[0].values.length > 0) {
                    hideCompletedEvents = result[0].values[0][0] === '1';
                }
            } catch (error) {
                console.warn('Konnte Event-Filter-Präferenz nicht laden:', error.message);
            }
        }

        // Anzahl der erledigten Events zählen
        function countCompletedEvents() {
            if (!db) return 0;

            try {
                const events = document.querySelectorAll('#eventsTableContainer tr.event-completed');
                return events.length;
            } catch (error) {
                return 0;
            }
        }

        // Event-Filter-Button-Text mit Anzahl aktualisieren
        function updateEventCompletedCount() {
            const button = document.getElementById('filter-event-erledigt');
            if (!button) return;

            const count = countCompletedEvents();
            button.textContent = `${count} Erledigt`;
        }

        // Events laden und anzeigen
        function loadEvents() {
            if (!db) return;
            
            try {
                const result = db.exec('SELECT * FROM events ORDER BY date');
                const container = document.getElementById('eventsTableContainer');
                
                if (result.length === 0) {
                    container.innerHTML = '<p>Keine Ereignisse gefunden</p>';
                    return;
                }
                
                const events = result[0].values;
                let html = `
                    <table>
                        <thead>
                            <tr>
                                <th>Ereignis</th>
                                <th>Datum</th>
                                <th>Beschreibung</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                events.forEach(event => {
                    const [id, eventName, date, description] = event;
                    const eventCompletedClass = isEventCompleted(id) ? 'event-completed' : '';
                    html += `
                        <tr class="${eventCompletedClass}">
                            <td>${eventName}</td>
                            <td>${date}</td>
                            <td>${description || ''}</td>
                            <td>
                                <button class="icon-btn" onclick="openEventModal(${id})" title="Ereignis bearbeiten">✏️</button>
                                <button class="icon-btn" onclick="duplicateEvent(${id})" title="Ereignis duplizieren">🔂</button>
                                <button class="icon-btn" onclick="deleteEvent(${id})" title="Ereignis löschen">🗑️</button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `</tbody></table>`;
                container.innerHTML = html;

                // Event-Filter anwenden
                applyEventFilter();

                // Stelle sicher, dass Button-Zustand korrekt ist
                setTimeout(() => updateEventFilterButtonStates(), 100);

            } catch (error) {
                console.error('Fehler beim Laden der Events:', error);
                showStatus('Fehler beim Laden der Events: ' + error.message, 'error');
            }
        }
        
        // Event duplizieren
        function duplicateEvent(id) {
            if (!db) return;
            
            try {
                const result = db.exec('SELECT * FROM events WHERE id = ?', [id]);
                if (result.length > 0) {
                    const event = result[0].values[0];
                    const [_, eventName, date, description] = event;
                    
                    // Neues Event mit kopierten Daten einfügen
                    db.run(
                        'INSERT INTO events (event, date, description) VALUES (?, ?, ?)',
                        [eventName, date, description]
                    );
                    
                    saveDatabase(true); // Echte Datenänderung - Event dupliziert
                    loadEvents();
                    showStatus('Event erfolgreich dupliziert', 'success');
                }
            } catch (error) {
                console.error('Fehler beim Duplizieren des Events:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }
        
        // Tasks laden und anzeigen
        function loadTasks(filterText = '') {
            if (!db) return;

            try {
                // ERWEITERTE ABFRAGE: Tasks mit Recurrence-Informationen einbeziehen
                const result = db.exec(`
                    SELECT t.*,
                           tr.id as recurrence_id,
                           tr.interval_value,
                           tr.interval_unit,
                           tr.max_occurrences,
                           tr.end_date,
                           tr.is_active as recurrence_active
                    FROM tasks t
                    LEFT JOIN task_recurrences tr ON tr.task_id = t.id AND tr.is_active = 1
                `);
                const container = document.getElementById('tasksContainer');

                if (result.length === 0) {
                    container.innerHTML = '<p>Keine Aufgaben gefunden</p>';
                    return;
                }

                let tasks = result[0].values;

                // Filter anwenden wenn filterText gegeben
                if (filterText) {
                    tasks = tasks.filter(task => {
                        const [id, eventType, taskType, description, range, value, unit, source, recurrenceId, intervalValue, intervalUnit, maxOccurrences, endDate, recurrenceActive] = task;
                        return [eventType, taskType, description, source].some(field =>
                            field && field.toLowerCase().includes(filterText.toLowerCase())
                        );
                    });
                }

                let html = '';

                tasks.forEach(task => {
                    const [id, eventType, taskType, description, range, value, unit, source, recurrenceId, intervalValue, intervalUnit, maxOccurrences, endDate, recurrenceActive] = task;
                    const hasDetails = description || range || value || unit || source || recurrenceId;
                    const isRecurring = recurrenceId && recurrenceActive;

                    // SYMBOL VOR TITEL: 🔄 für wiederkehrende Tasks
                    const symbolPrefix = isRecurring ? '🔄 ' : '';

                    html += `
                        <div class="task-card">
                            <div class="task-row">
                                <div class="task-main">
                                    <span class="task-title">${symbolPrefix}${taskType}</span>
                                    <span class="task-event">${eventType}</span>
                                </div>
                                <div class="task-actions">
                                    <button class="icon-btn" onclick="openTaskModal(${id})" title="Aufgabe bearbeiten">✏️</button>
                                    <button class="icon-btn" onclick="duplicateTask(${id})" title="Aufgabe duplizieren">🔂</button>
                                    <button class="icon-btn" onclick="deleteTask(${id})" title="Aufgabe löschen">🗑️</button>
                                </div>
                            </div>
                            <button class="accordion-toggle" onclick="toggleAccordion(this)">▶ Details</button>
                            <div class="accordion-content">
                                ${description ? `<p><strong>${TEXT_CONFIG.taskDescriptionLabel}:</strong> ${description}</p>` : ''}
                                <p><strong>${TEXT_CONFIG.rangeLabel}:</strong> ${range}</p>
                                <p><strong>${TEXT_CONFIG.valueLabel}:</strong> ${value}</p>
                                <p><strong>${TEXT_CONFIG.unitLabel}:</strong> ${unit}</p>
                                ${source ? `<p><strong>${TEXT_CONFIG.sourceLabel.split(' (')[0]}:</strong> ${isUrl(source) ? `<a href="${source}" target="_blank" class="source-link">${extractDomain(source) || 'Link'}</a>` : source}</p>` : ''}
                                ${isRecurring ? `
                                    <hr style="margin: 15px 0; border: none; border-top: 1px solid #eee;">
                                    <p><strong style="color: #2563eb;">🔄 Wiederholung aktiviert</strong></p>
                                    <p><strong>Intervall:</strong> Alle ${intervalValue} ${getLocalizedUnit(intervalUnit)}</p>
                                    ${maxOccurrences && maxOccurrences > 0 ? `<p><strong>Anzahl:</strong> ${maxOccurrences} mal</p>` : '<p><strong>Maximale Häufigkeit:</strong> unbegrenzt</p>'}
                                    ${endDate ? `<p><strong>Enddatum:</strong> ${endDate}</p>` : '<p><strong>Enddatum:</strong> keine Begrenzung</p>'}
                                ` : ''}
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;

            } catch (error) {
                console.error('Fehler beim Laden der Tasks:', error);
                showStatus('Fehler beim Laden der Tasks: ' + error.message, 'error');
            }
        }

        // Generiere wiederkehrende Todos
        function generateRecurringTodos(task, recurrence) {
            const todos = [];
            const baseDate = new Date(task.eventDate);
            const maxDate = new Date();
            maxDate.setFullYear(maxDate.getFullYear() + 2); // 2-Jahres-Limit

            // FIX: Berechne die erste Deadline einmalig (Range nur einmal anwenden)
            const firstDeadline = calculateDeadline(
                baseDate.toISOString().split('T')[0],
                task.range, task.value, task.unit
            );
            let currentDate = new Date(firstDeadline);
            let occurrenceCount = 0;

            while (true) {
                // Prüfe Limits
                if (recurrence.maxOccurrences > 0 && occurrenceCount >= recurrence.maxOccurrences) break;
                if (recurrence.endDate && currentDate > new Date(recurrence.endDate)) break;
                if (currentDate > maxDate) break; // Sicherheitslimit

                // FIX: Verwende currentDate als deadline (bereits mit Range korrigiert)
                const deadline = currentDate.toISOString().split('T')[0];

                // Prüfe, ob Instanz bereits erledigt ist
                const completed = isTodoCompleted(task.taskId, task.eventId, deadline);

                // Prüfe, ob Instanz bereits exportiert wurde
                const exported = isTodoExported(task.taskId, task.eventId, deadline);

                todos.push({
                    type: 'task',
                    eventId: task.eventId,
                    eventName: task.eventName,
                    eventDate: task.eventDate,
                    eventDescription: task.eventDescription,
                    taskId: task.taskId,
                    taskType: task.taskType,
                    taskDescription: task.taskDescription,
                    deadline: deadline,
                    range: task.range,
                    value: task.value,
                    unit: task.unit,
                    source: task.source,
                    completed: completed,
                    exported: exported,
                    isRecurring: true,
                    occurrenceDate: deadline, // FIX: occurrence_date ist die deadline
                    recurrenceId: recurrence.id
                });

                // Nächste Instanz berechnen (Intervall auf deadline addieren)
                currentDate = addInterval(currentDate, recurrence.intervalValue, recurrence.intervalUnit);
                occurrenceCount++;
            }

            return todos;
        }

        // Hilfsfunktion: Prüft, ob eine Todo-Instanz erledigt ist
        function isTodoCompleted(taskId, eventId, occurrenceDate) {
            try {
                let query, params;
                
                if (occurrenceDate && occurrenceDate !== 'undefined' && occurrenceDate !== 'null') {
                    // Wiederkehrende Instanz - prüfe mit occurrence_date
                    query = 'SELECT completed FROM completed_tasks WHERE task_id = ? AND event_id = ? AND occurrence_date = ?';
                    params = [taskId, eventId, occurrenceDate];
                } else {
                    // Normaler Task - prüfe ohne occurrence_date
                    query = 'SELECT completed FROM completed_tasks WHERE task_id = ? AND event_id = ? AND occurrence_date IS NULL';
                    params = [taskId, eventId];
                }
                
                const result = db.exec(query, params);
                const isCompleted = result.length > 0 && result[0].values.length > 0 && result[0].values[0][0] === 1;
                return isCompleted;
            } catch (error) {
                console.error('❌ Fehler bei Todo-Status-Prüfung:', error);
                console.error('Params:', { taskId, eventId, occurrenceDate });
                
                // Fallback: Versuche ohne occurrence_date (kompatibel mit alten DBs)
                try {
                    const fallbackQuery = 'SELECT completed FROM completed_tasks WHERE task_id = ? AND event_id = ?';
                    const fallbackResult = db.exec(fallbackQuery, [taskId, eventId]);
                    return fallbackResult.length > 0 && fallbackResult[0].values.length > 0 && fallbackResult[0].values[0][0] === 1;
                } catch (fallbackError) {
                    console.error('❌ Auch Fallback-Query fehlgeschlagen:', fallbackError);
                    return false;
                }
            }
        }
        // Hilfsfunktion: Prüft, ob eine Todo-Instanz exportiert wurde
        function isTodoExported(taskId, eventId, occurrenceDate) {
            try {
                // Für wiederkehrende Tasks: Prüfe nach occurrence_date (spezifische Instanz)
                // Für normale Tasks: Prüfe nach start_date (occurrenceDate ist dann die deadline)
                const query = 'SELECT id FROM calendar_todos WHERE task_id = ? AND event_id = ? AND start_date = ?';
                const result = db.exec(query, [taskId, eventId, occurrenceDate]);

                const isExported = result.length > 0 && result[0].values.length > 0;
                return isExported;
            } catch (error) {
                console.error('❌ Fehler bei Todo-Export-Prüfung:', error);
                console.error('Params:', { taskId, eventId, occurrenceDate });
                return false; // Export-Status ist nicht kritisch für Funktionalität
            }
        }

        // Hilfsfunktion: Fügt Interval zu Datum hinzu
        function addInterval(date, value, unit) {
            const newDate = new Date(date);
            switch (unit) {
                case 'days':
                    newDate.setDate(newDate.getDate() + value);
                    break;
                case 'weeks':
                    newDate.setDate(newDate.getDate() + (value * 7));
                    break;
                case 'months':
                    newDate.setMonth(newDate.getMonth() + value);
                    break;
                case 'years':
                    newDate.setFullYear(newDate.getFullYear() + value);
                    break;
            }
            return newDate;
        }

        // To-Dos laden und anzeigen
        function loadTodos() {
            
            if (!db) {
                
                return;
            }

            try {
                // NEUE ABFRAGE: Tasks mit Recurrence-Informationen einbeziehen
                const query = `
                    SELECT
                        e.id as event_id,
                        e.event as event_name,
                        e.date as event_date,
                        e.description as event_description,
                        t.id as task_id,
                        t.event_type,
                        t.task_type,
                        t.description as task_description,
                        t.range,
                        t.value,
                        t.unit,
                        t.source,
                        NULL as completed,  -- Für Recurring Tasks wird das später ermittelt
                        0 as calendar_exported,  -- Export-Status wird später pro Instanz geprüft
                        tr.id as recurrence_id,
                        tr.interval_value,
                        tr.interval_unit,
                        tr.max_occurrences,
                        tr.end_date
                    FROM events e
                    INNER JOIN tasks t ON e.event = t.event_type
                    LEFT JOIN task_recurrences tr ON tr.task_id = t.id AND tr.is_active = 1
                `;

                const result = db.exec(query);
                const container = document.getElementById('todosContainer');

                if (result.length === 0) {
                    container.innerHTML = '<p>Keine To-Dos gefunden</p>';
                    return;
                }

                const todos = result[0].values;

                // Sammle alle Todos (Tasks und Events ohne Tasks)
                let allTodos = [];

                todos.forEach(todo => {
                    const [eventId, eventName, eventDate, eventDescription, taskId, eventType, taskType, taskDescription, range, value, unit, source, completed, calendarExported, recurrenceId, intervalValue, intervalUnit, maxOccurrences, endDate] = todo;

                    if (taskId !== null) {
                        if (recurrenceId) {
                            // WIEDERKEHRENDER TASK - Generiere mehrere Instanzen
                            const recurringTodos = generateRecurringTodos({
                                taskId, eventId, eventName, eventDate, eventDescription,
                                taskType, taskDescription, range, value, unit, source
                            }, {
                                id: recurrenceId,
                                intervalValue,
                                intervalUnit,
                                maxOccurrences,
                                endDate
                            });

                            // Füge alle generierten Instanzen hinzu
                            allTodos.push(...recurringTodos);
                        } else {
                            // NORMALER EINMALIGER TASK
                            const deadline = calculateDeadline(eventDate, range, value, unit);
                            
                            // Status für normale Tasks prüfen - ROBUST für alte DBs
                            let normalTaskCompleted = false;
                            try {
                                // Versuche zuerst mit occurrence_date IS NULL (neue DB-Struktur)
                                const normalTaskQuery = 'SELECT completed FROM completed_tasks WHERE task_id = ? AND event_id = ? AND occurrence_date IS NULL';
                                const normalTaskResult = db.exec(normalTaskQuery, [taskId, eventId]);
                                normalTaskCompleted = normalTaskResult.length > 0 && normalTaskResult[0].values.length > 0 && normalTaskResult[0].values[0][0] === 1;

                            } catch (error) {

                                // Fallback für alte DBs ohne occurrence_date Spalte
                                try {
                                    const fallbackQuery = 'SELECT completed FROM completed_tasks WHERE task_id = ? AND event_id = ?';
                                    const fallbackResult = db.exec(fallbackQuery, [taskId, eventId]);
                                    normalTaskCompleted = fallbackResult.length > 0 && fallbackResult[0].values.length > 0 && fallbackResult[0].values[0][0] === 1;

                                } catch (fallbackError) {
                                    console.error('❌ Auch Fallback-Query fehlgeschlagen:', fallbackError);
                                    normalTaskCompleted = false;
                                }
                            }
                            
                            // Export-Status für normale Tasks prüfen
                            const normalTaskExported = db.exec(`
                                SELECT id FROM calendar_todos
                                WHERE event_id = ? AND task_id = ? AND start_date = ?
                            `, [eventId, taskId, deadline])[0]?.values.length > 0;


                            allTodos.push({
                                type: 'task',
                                eventId: eventId,
                                eventName: eventName,
                                eventDate: eventDate,
                                eventDescription: eventDescription,
                                taskId: taskId,
                                taskType: taskType,
                                taskDescription: taskDescription,
                                deadline: deadline,
                                range: range,
                                value: value,
                                unit: unit,
                                source: source,
                                completed: normalTaskCompleted, // Verwende korrekt ermittelten Status
                                exported: normalTaskExported
                            });
                        }
                    }
                });

                // Sammle Events ohne Tasks (einzigartige Events, die keine Tasks haben)
                const processedEvents = new Set();
                todos.forEach(todo => {
                    const [eventId, eventName, eventDate, eventDescription, taskId] = todo;
                    if (taskId === null && !processedEvents.has(eventId)) {
                        // Event ohne zugeordneten Task - verwende Eventdatum als Sortierdatum
                        // Export-Status für Events prüfen
                        const eventExported = db.exec(`
                            SELECT id FROM calendar_todos
                            WHERE event_id = ? AND task_id IS NULL AND start_date = ?
                        `, [eventId, eventDate])[0]?.values.length > 0;

                        allTodos.push({
                            type: 'event',
                            eventId: eventId,
                            eventName: eventName,
                            eventDate: eventDate,
                            eventDescription: eventDescription,
                            taskId: null,
                            taskType: null,
                            taskDescription: null,
                            deadline: eventDate, // Verwendet Eventdatum als Sortierdatum
                            range: null,
                            value: null,
                            unit: null,
                            source: null,
                            completed: false, // Events können nicht "erledigt" werden
                            exported: eventExported
                        });
                        processedEvents.add(eventId);
                    }
                });

                // Alle Todos sortieren (älteste zuerst)
                allTodos.sort((a, b) => {
                    return new Date(a.deadline) - new Date(b.deadline);
                });

                

                // Überprüfen auf wiederkehrende Tasks
                const recurringTasks = todos.filter(todo => todo[14]).length; // Check recurrenceId (Fix: Index 14 statt 13)
                

                // Zählungen basierend auf generierten Todos berechnen
                let anstCount = 0, offenCount = 0, ueberfaelligCount = 0, completedCount = 0;

                allTodos.forEach(todo => {
                    if (todo.completed) {
                        completedCount++;
                    } else if (todo.type === 'event') {
                        // Events werden nicht gezählt
                    } else {
                        const urgencyClass = getDeadlineUrgencyClass(todo.deadline, false);
                        if (urgencyClass === 'deadline-overdue') {
                            ueberfaelligCount++;
                        } else if (urgencyClass === 'deadline-normal') {
                            offenCount++;
                        } else {
                            anstCount++; // critical, warning, soon
                        }
                    }
                });

                // Zählungen global speichern
                todoCounts = {
                    erledigt: completedCount,
                    anstehend: anstCount,
                    offen: offenCount,
                    ueberfaellig: ueberfaelligCount
                };

                // Speichere allTodos global für andere Funktionen
                window.allTodos = allTodos;
                

                // Setze auch die lokale Variable
                allTodos = allTodos.slice(); // Erstelle Kopie

                // HTML für die sortierten Todos generieren
                let html = '';
                allTodos.forEach(todo => {
                    if (todo.type === 'task') {
                        // Task-Eintrag
                        const isCompleted = todo.completed;

                        if (todo.isRecurring) {
                            
                        }

                        html += `
                            <li class="todo-item ${isCompleted ? 'completed' : ''}">
                                <div class="todo-content">
                                    <div class="todo-main">
                                        <span class="todo-type">${todo.taskType}</span>${todo.isRecurring ? ' <small style="color: #666; font-weight: normal;">🔄 wiederkehrend</small>' : ''}<br>
                                        <strong>${todo.eventName}</strong> am ${todo.eventDate}${todo.eventDescription ? ` (${todo.eventDescription})` : ''}
                                        ${todo.taskDescription ? `<div class="todo-description">${todo.taskDescription}</div>` : ''}
                                        <div class="todo-date ${getDeadlineUrgencyClass(todo.deadline, isCompleted)}" onclick="downloadTodoICS(${todo.eventId}, ${todo.taskId ? todo.taskId : 'null'}, ${todo.occurrenceDate ? `'${todo.occurrenceDate}'` : 'null'})" style="cursor: pointer;" title="${todo.exported ? 'Kalender wurde bereits exportiert' : 'Als Kalendereintrag exportieren'}" aria-label="Todo als ICS-Datei exportieren">${getCalendarSVGIcon(todo.deadline, isCompleted, todo.exported)}Fällig: ${todo.deadline} ${formatRangeText(todo.range, todo.value, todo.unit)}</div>
                                    </div>
                                    ${todo.source ? `
                                        <div class="todo-source">
                                            ${isUrl(todo.source) ?
                                                `<a href="${todo.source}" target="_blank" class="source-link">${extractDomain(todo.source)}</a>` :
                                                `<span>${todo.source}</span>`
                                            }
                                        </div>
                                    ` : ''}
                                </div>
                                <div class="todo-actions">
                                      <input type="checkbox" class="todo-checkbox"
                                          data-task-id="${todo.taskId}"
                                          data-event-id="${todo.eventId}"
                                          ${todo.occurrenceDate ? `data-occurrence-date="${todo.occurrenceDate}"` : ''}
                                          ${isCompleted ? 'checked' : ''}
                                          onchange="toggleTaskCompletion(this)"
                                          title="${todo.occurrenceDate ? `Instanz vom ${todo.occurrenceDate} als erledigt markieren` : 'Als erledigt markieren'}"
                                          aria-label="${todo.occurrenceDate ? `Instanz vom ${todo.occurrenceDate} als erledigt markieren` : 'Aufgabe als erledigt markieren'}">
                                  </div>
                            </li>
                        `;
                    } else if (todo.type === 'event') {
                        // Event ohne Task - angezeigt wie vorher als Warnung
                        html += `
                            <li class="todo-item no-tasks-warning" style="padding: 15px; border-radius: 4px; border-left: 4px solid var(--warning); box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                                <div style="margin-left: 11px;">
                                    <strong>${todo.eventName} am ${todo.eventDate}${todo.eventDescription ? ` (${todo.eventDescription})` : ''}</strong><br>
                                    ${TEXT_CONFIG.noTasksWarning}
                                </div>
                            </li>
                        `;
                    }
                });

                if (allTodos.length === 0) {
                    html = '<p>Keine To-Dos oder Events gefunden</p>';
                }

                container.innerHTML = html;

                // Filter-Status nach dem Laden der Todos anwenden
                updateFilterButtonStates();
                applyTodoFilters();

                // Anzahl der Aufgaben aktualisieren
                updateTodoCounts();

            } catch (error) {
                console.error('Fehler beim Laden der To-Dos:', error);
                showStatus('Fehler beim Laden der To-Dos: ' + error.message, 'error');
            }
        }
        
        // Prüfen, ob ein String eine URL ist
        function isUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        // Domain aus URL extrahieren
        function extractDomain(url) {
            try {
                const parsedUrl = new URL(url);
                return parsedUrl.hostname;
            } catch (_) {
                return "Link";
            }
        }

        // UUID v4 Generierung
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // ICS-Datei-Generierung für Todo
        function generateICSContent(uuid, eventId, taskId, occurrenceDate = null) {
            try {
                // Todo-Daten laden
                const result = db.exec(`
                    SELECT
                        e.event as event_name,
                        e.date as event_date,
                        e.description as event_description,
                        t.task_type,
                        t.description as task_description,
                        t.range,
                        t.value,
                        t.unit,
                        t.source
                    FROM events e
                    LEFT JOIN tasks t ON t.id = ?
                    WHERE e.id = ?
                `, [taskId, eventId]);

                if (result.length === 0 || result[0].values.length === 0) {
                    throw new Error('Todo-Daten nicht gefunden');
                }

                const [eventName, eventDate, eventDescription, taskType, taskDescription, range, value, unit, source] = result[0].values[0];


                // Deadline berechnen (für Events ohne Tasks verwende Event-Datum)
                let deadline;
                if (occurrenceDate) {
                    // Für wiederkehrende Tasks: Verwende die übergebene occurrenceDate
                    deadline = occurrenceDate;
                } else if (taskId && range && value && unit) {
                    deadline = calculateDeadline(eventDate, range, value, unit);
                } else {
                    deadline = eventDate;
                }

                // ICS-Header
                let ics = `BEGIN:VCALENDAR\r\n`;
                ics += `VERSION:2.0\r\n`;
                ics += `PRODID:-//ToDo Manager//ICS Export//EN\r\n`;
                ics += `METHOD:PUBLISH\r\n`;

                // Event-Block
                ics += `BEGIN:VEVENT\r\n`;
                ics += `UID:${uuid}\r\n`;
                ics += `DTSTAMP:${new Date().toISOString().replace(/[:-]/g, '').replace(/\.\d{3}/, '')}Z\r\n`;
                ics += `DTSTART;VALUE=DATE:${deadline.replace(/-/g, '')}\r\n`;
                ics += `DTEND;VALUE=DATE:${deadline.replace(/-/g, '')}\r\n`;

                // Titel generieren (nur Taskname, keine Event-Kombination)
                const title = taskType || eventName;
                ics += `SUMMARY:${title.replace(/[\\;,\n]/g, '\\$&')}\r\n`;

                // Beschreibung zusammenstellen im gewünschten Format
                let description = '';

                // Event-Info in Klammern (mit Datum) - Eventname + Eventbeschreibung kombinieren
                let eventDisplayName = eventName || '';
                if (eventDescription && eventDescription.trim()) {
                    eventDisplayName += (eventDisplayName ? ' ' : '') + eventDescription;
                }
                if (!eventDisplayName.trim()) {
                    eventDisplayName = 'Unbenanntes Event';
                }
                description += `(${eventDisplayName} am ${eventDate})`;

                // Zeilenwechsel und Task-Beschreibung darunter (falls vorhanden)
                if (taskDescription) {
                    description += ' ' + taskDescription;
                }

                if (description.trim()) {
                    // Beschreibung korrekt escapen: erst \n verarbeiten, dann \\n escapen
                    const escapedDesc = description.replace(/\n/g, '\\n').replace(/[\\;]/g, '\\$&');
                    ics += `DESCRIPTION:${escapedDesc}\r\n`;
                }

                // URL hinzufügen, falls vorhanden
                if (source && source.trim()) {
                    ics += `URL:${source}\r\n`;
                }

                ics += `END:VEVENT\r\n`;
                ics += `END:VCALENDAR\r\n`;

                return ics;

            } catch (error) {
                console.error('Fehler bei ICS-Generierung:', error);
                throw error;
            }
        }

        // Calendar-Todo mit UUID erstellen/verwenden
        function getOrCreateCalendarTodo(eventId, taskId, occurrenceDate = null) {
            if (!db) {
                throw new Error('Datenbank nicht initialisiert');
            }

            try {
                // Prüfen ob bereits vorhanden - für wiederkehrende Tasks nach occurrenceDate suchen
                let existingQuery;
                let existingParams;

                if (occurrenceDate) {
                    // Für wiederkehrende Tasks: Nach spezifischer occurrenceDate suchen
                    existingQuery = `
                        SELECT id, uuid FROM calendar_todos
                        WHERE event_id = ? AND task_id = ? AND start_date = ?
                    `;
                    existingParams = [eventId, taskId, occurrenceDate];
                } else {
                    // Für normale Tasks: Nach allgemeinem Eintrag suchen
                    existingQuery = `
                        SELECT id, uuid FROM calendar_todos
                        WHERE event_id = ? AND ((task_id IS NULL AND ? IS NULL) OR task_id = ?)
                    `;
                    existingParams = [eventId, taskId, taskId];
                }

                const result = db.exec(existingQuery, existingParams);

                if (result.length > 0 && result[0].values.length > 0) {
                    // Bereits vorhanden - UUID zurückgeben
                    const existingId = result[0].values[0][0];
                    const uuid = result[0].values[0][1];

                    // Export-Zeitpunkt aktualisieren
                    db.run(`
                        UPDATE calendar_todos
                        SET exported_at = datetime('now')
                        WHERE id = ?
                    `, [existingId]);

                    return uuid;
                }

                // Neu erstellen
                const uuid = generateUUID();

                // Todo-Daten laden für Titel/Beschreibung
                const todoData = db.exec(`
                    SELECT
                        e.event as event_name,
                        e.date as event_date,
                        e.description as event_description,
                        t.task_type,
                        t.description as task_description,
                        t.range,
                        t.value,
                        t.unit,
                        t.source
                    FROM events e
                    LEFT JOIN tasks t ON t.id = ?
                    WHERE e.id = ?
                `, [taskId, eventId]);

                if (todoData.length === 0 || todoData[0].values.length === 0) {
                    throw new Error('Todo-Daten nicht gefunden');
                }

                const [eventName, eventDate, eventDescription, taskType, taskDescription, range, value, unit, source] = todoData[0].values[0];

                // Deadline berechnen (für Events ohne Tasks verwende Event-Datum)
                let deadline;
                if (taskId) {
                    if (occurrenceDate) {
                        // Für wiederkehrende Tasks: occurrenceDate IST bereits die korrekte deadline
                        deadline = occurrenceDate;
                    } else {
                        // Für normale Tasks: Verwende Event-Datum als Basis
                        deadline = calculateDeadline(eventDate, range, value, unit);
                    }
                } else {
                    deadline = eventDate;
                }

                // Titel generieren (nur Task-Name)
                const title = taskType || eventName;

                // Beschreibung zusammenstellen im gewünschten Format
                let description = '';

                // Event-Info in Klammern (mit Datum) - Eventname + Eventbeschreibung kombinieren
                let eventDisplayName = eventName || '';
                if (eventDescription && eventDescription.trim()) {
                    eventDisplayName += (eventDisplayName ? ' ' : '') + eventDescription;
                }
                if (!eventDisplayName.trim()) {
                    eventDisplayName = 'Unbenanntes Event';
                }

                if (occurrenceDate) {
                    // Für wiederkehrende Tasks: Zeige Instanz-Datum
                    description += `(${eventDisplayName} - Instanz vom ${occurrenceDate})`;
                } else {
                    // Für normale Tasks: Zeige Event-Datum
                    description += `(${eventDisplayName} am ${eventDate})`;
                }

                // Task-Beschreibung darunter (falls vorhanden)
                if (taskDescription) {
                    description += ' ' + taskDescription;
                }

                // In Datenbank speichern
                db.run(`
                    INSERT INTO calendar_todos
                    (uuid, event_id, task_id, title, start_date, description, exported_at)
                    VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
                `, [uuid, eventId, taskId, title, deadline, description]);

                saveDatabase(true); // Echte Datenänderung - ICS-Export als lokale Änderung verfolgen
                return uuid;

            } catch (error) {
                console.error('Fehler bei Calendar-Todo-Erstellung:', error);
                throw error;
            }
        }

        // ICS-Datei herunterladen
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/calendar;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        }

        // Todo als ICS exportieren
        function downloadTodoICS(eventId, taskIdStr, occurrenceDate = null) {
            try {
                // String 'null' zu JavaScript null konvertieren
                const taskId = taskIdStr === 'null' ? null : parseInt(taskIdStr);
                // String 'null' auch für occurrenceDate behandeln
                const finalOccurrenceDate = (occurrenceDate === 'null' || occurrenceDate === '') ? null : occurrenceDate;
                
                const uuid = getOrCreateCalendarTodo(eventId, taskId, finalOccurrenceDate);
                const icsContent = generateICSContent(uuid, eventId, taskId, finalOccurrenceDate);

                // Task-Typ und Event-Datum für Dateiname laden
                const dataResult = db.exec(`
                    SELECT
                        t.task_type,
                        e.date as event_date,
                        t.source
                    FROM events e
                    LEFT JOIN tasks t ON t.id = ?
                    WHERE e.id = ?
                `, [taskId, eventId]);

                let filename;
                if (dataResult.length > 0 && dataResult[0].values.length > 0) {
                    const [taskType, eventDate] = dataResult[0].values[0];

                    // Verwende Task-Typ oder Event-Name als Fallback
                    const namePart = taskType || 'Unbenanntes_Event';
                    // Sichere Dateinamen: Leerzeichen durch Unterstriche, ungültige Zeichen entfernen
                    const safeNamePart = namePart.replace(/[^a-zA-Z0-9_-]/g, '_');
                    filename = `${safeNamePart}_${eventDate}.ics`;
                } else {
                    // Fallback zu UUID, falls Daten nicht gefunden werden
                    filename = `${uuid}.ics`;
                }

                downloadFile(filename, icsContent);
                showStatus('ICS-Datei erfolgreich exportiert', 'success');
                saveDatabase(true); // Lokale Änderung für Sync registrieren

                // UI neu laden um Export-Status zu aktualisieren
                loadTodos();
                loadEvents();
                // Sync-Status aktualisieren um automatischen Upload zu triggern
                updateSyncIndicator();

            } catch (error) {
                console.error('Fehler beim ICS-Export:', error);
                showStatus('Fehler beim ICS-Export: ' + error.message, 'error');
            }
        }
        
        // Hilfsfunktion für die formatierte Anzeige der Range-Information
        function formatRangeText(range, value, unit) {
            if (range === 'am') {
                return '(am)';
            } else {
                return `(${value} ${unit} ${range})`;
            }
        }

        // Hilfsfunktion für die Lokalisierung von Interval-Einheiten
        function getLocalizedUnit(unit) {
            switch(unit) {
                case 'days': return TEXT_CONFIG.unitDays;
                case 'weeks': return TEXT_CONFIG.unitWeeks;
                case 'months': return TEXT_CONFIG.unitMonths;
                case 'years': return TEXT_CONFIG.unitYears;
                default: return unit; // Fallback für unbekannte Units
            }
        }

        // Deadline berechnen basierend auf Event-Datum, Range, Value und Unit
        function calculateDeadline(eventDate, range, value, unit) {
            const date = new Date(eventDate);

            if (range === 'am') {
                return date.toISOString().split('T')[0];
            }

            // Range-Faktor bestimmen (-1 für 'davor', +1 für 'danach')
            const direction = (range === 'davor') ? -1 : 1;
            const parsedValue = parseInt(value);

            // Datum basierend auf Unit anpassen
            if (unit === 'Tage') {
                date.setDate(date.getDate() + (direction * parsedValue));
            } else if (unit === 'Wochen') {
                date.setDate(date.getDate() + (direction * parsedValue * 7));
            } else if (unit === 'Monate') {
                // KALENDARISCHE MONATSBERECHNUNG
                date.setMonth(date.getMonth() + (direction * parsedValue));
            }

            return date.toISOString().split('T')[0];
        }

        // Urgency-Klasse für Deadline-Datum berechnen
        function getDeadlineUrgencyClass(deadline, isCompleted = false) {
            if (isCompleted) {
                return 'deadline-completed';
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0); // Nur Datum, keine Zeit

            const deadlineDate = new Date(deadline);
            deadlineDate.setHours(0, 0, 0, 0);

            // Verbleibende Tage bis Deadline
            const daysDifference = Math.floor((deadlineDate - today) / (1000 * 60 * 60 * 24));

            if (daysDifference < 0) {
                // Überfällig
                return 'deadline-overdue';
            } else if (daysDifference <= DEADLINE_CONFIG.critical) {
                // Kritischer Zeitraum (< DEADLINE_CONFIG.critical Tage)
                return 'deadline-critical';
            } else if (daysDifference <= DEADLINE_CONFIG.warning) {
                // Warning-Bereich ((DEADLINE_CONFIG.critical+1)-DEADLINE_CONFIG.warning Tage)
                return 'deadline-warning';
            } else if (daysDifference <= DEADLINE_CONFIG.soon) {
                // Soon-Bereich ((DEADLINE_CONFIG.warning+1)-DEADLINE_CONFIG.soon Tage)
                return 'deadline-soon';
            } else {
                // Normal-Bereich (> DEADLINE_CONFIG.soon Tage)
                return 'deadline-normal';
            }
        }

        // Farbe basierend auf Deadline-Status ermitteln
        function getDeadlineColor(deadline, isCompleted = false) {
            if (isCompleted) {
                return '#95a5a6'; // grau für erledigte Tasks
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const deadlineDate = new Date(deadline);
            deadlineDate.setHours(0, 0, 0, 0);

            const daysDifference = Math.floor((deadlineDate - today) / (1000 * 60 * 60 * 24));

            if (daysDifference < 0) {
                // Überfällig
                return '#8b0000'; // dunkelrot
            } else if (daysDifference <= DEADLINE_CONFIG.critical) {
                // Kritischer Zeitraum
                return '#8b0000'; // dunkelrot
            } else if (daysDifference <= DEADLINE_CONFIG.warning) {
                // Warning-Bereich
                return '#f39c12'; // orange
            } else if (daysDifference <= DEADLINE_CONFIG.soon) {
                // Soon-Bereich
                return '#f1c40f'; // gelb
            } else {
                // Normal-Bereich
                return '#27ae60'; // grün
            }
        }

        // SVG-Kalendericon mit dynamischem Tag generieren
        function getCalendarSVGIcon(deadline, isCompleted = false, exported = false) {

            // Tag aus dem Datum extrahieren (Format: YYYY-MM-DD)
            const dateParts = deadline.split('-');
            const day = parseInt(dateParts[2], 10);

            // Wenn bereits exportiert, dunkler grau darstellen
            let color;
            if (exported) {
                color = '#6c757d'; // dunkleres grau für exportierte Todos
            } else {
                // Farbe basierend auf Deadline-Status
                color = getDeadlineColor(deadline, isCompleted);
            }

            // SVG basierend auf deiner Vorlage
            return `
                <!-- Kalender-Icon als SVG, frei skalierbar -->
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    aria-label="Kalender ${day}${exported ? ' (bereits exportiert)' : ''}"
                    role="img"
                    width="20" height="20"
                    style="
                        vertical-align: middle;
                        margin-right: 6px;
                        ${exported ? 'opacity: 0.7;' : ''}
                    "
                >
                    <!-- Rahmen -->
                    <rect x="2" y="3" width="20" height="18"
                        rx="3" ry="3"
                        fill="var(--card-bg)"
                        stroke="${color}" stroke-width="1.5"/>

                    <!-- Ringe oben (Kalenderbinder) -->
                    <g fill="none" stroke="${color}" stroke-width="2.5" stroke-linecap="round">
                        <path d="M8 3v-1.2"/>   <!-- linker Ring -->
                        <path d="M16 3v-1.2"/> <!-- rechter Ring -->
                    </g>

                    <!-- Datum (zentriert) -->
                    <text x="12" y="17" fill="${color}" text-anchor="middle" font-size="10" font-weight="600" font-family="system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif">${day}</text>
                </svg>
            `;
        }
        // Accordion-Menü für Task-Details umschalten
        function toggleAccordion(button) {
            const card = button.parentElement;
            const content = card.querySelector('.accordion-content');

            if (content.classList.contains('show')) {
                content.classList.remove('show');
                button.textContent = '▶ Details';
            } else {
                content.classList.add('show');
                button.textContent = '▼ Details';
            }
        }

        // Task-Completion umschalten
        function toggleTaskCompletion(checkbox) {
            if (!db) return;

            const taskId = checkbox.dataset.taskId;
            const eventId = checkbox.dataset.eventId;
            const completed = checkbox.checked ? 1 : 0;
            const occurrenceDate = checkbox.dataset.occurrenceDate; // Neu für wiederkehrende Tasks



            try {
                // VERBESSERTE ROBUST HANDLING für occurrence_date
                if (completed) {
                    if (occurrenceDate && occurrenceDate !== 'undefined' && occurrenceDate !== 'null') {
                        // WIEDERKEHRENDE INSTANZ: Speichere mit occurrence_date

                        const query = 'INSERT OR REPLACE INTO completed_tasks (task_id, event_id, completed, completed_at, occurrence_date, recurrence_id) VALUES (?, ?, ?, datetime("now"), ?, NULL)';
                        db.run(query, [taskId, eventId, completed, occurrenceDate]);

                    } else {
                        // NORMALER TASK: Speichere ohne occurrence_date (NULL)

                        const query = 'INSERT OR REPLACE INTO completed_tasks (task_id, event_id, completed, completed_at, occurrence_date, recurrence_id) VALUES (?, ?, ?, datetime("now"), NULL, NULL)';
                        db.run(query, [taskId, eventId, completed]);

                    }
                } else {
                    if (occurrenceDate && occurrenceDate !== 'undefined' && occurrenceDate !== 'null') {
                        // WIEDERKEHRENDE INSTANZ: Lösche mit occurrence_date

                        const query = 'DELETE FROM completed_tasks WHERE task_id = ? AND event_id = ? AND occurrence_date = ?';
                        db.run(query, [taskId, eventId, occurrenceDate]);

                    } else {
                        // NORMALER TASK: Lösche ohne occurrence_date

                        const query = 'DELETE FROM completed_tasks WHERE task_id = ? AND event_id = ? AND occurrence_date IS NULL';
                        db.run(query, [taskId, eventId]);

                    }
                }


                saveDatabase(true); // Echte Datenänderung - Task-Status geändert
                loadTodos();
                loadEvents(); // Event-Status in Event-Liste aktualisieren
                updateTodoCounts(); // Anzahl der Aufgaben nach Statusänderung aktualisieren
                showStatus('Task-Status aktualisiert', 'success');

                // Event-Filter neu anwenden falls Tab aktiv ist
                if (currentTab === 'events') {
                    applyEventFilter();
                }

                // Sync-Status aktualisieren
                updateSyncIndicator();

            } catch (error) {
                console.error('❌ FEHLER beim Aktualisieren des Task-Status:', error);
                console.error('Error details:', error.message);
                console.error('SQL Error code:', error.code);
                console.error('Params:', { taskId, eventId, completed, occurrenceDate });

                // Schema-Migration erneut versuchen

                try {
                    migrateCompletedTasksTable();
                    showStatus('Schema wurde repariert. Bitte erneut versuchen.', 'warning');
                } catch (migrationError) {
                    console.error('❌ Schema-Migration fehlgeschlagen:', migrationError);
                }

                showStatus('Fehler: ' + error.message, 'error');

                // Checkbox zurücksetzen bei Fehler
                checkbox.checked = !checkbox.checked;
            }
        }
        
        // Event-Modal öffnen
        function openEventModal(eventId = null) {
            // Vorschläge laden, falls noch nicht geschehen
            loadEventTypes();
            const modal = document.getElementById('eventModal');
            const title = document.getElementById('eventModalTitle');
            const form = document.getElementById('eventForm');
            
            if (eventId) {
                // Bestehendes Event bearbeiten
                title.textContent = TEXT_CONFIG.editEventTitle;
                
                try {
                    const result = db.exec('SELECT * FROM events WHERE id = ?', [eventId]);
                    if (result.length > 0) {
                        const event = result[0].values[0];
                        document.getElementById('eventId').value = event[0];
                        document.getElementById('eventName').value = event[1];
                        document.getElementById('eventDate').value = event[2];
                        document.getElementById('eventDescription').value = event[3] || '';
                    }
                } catch (error) {
                    console.error('Fehler beim Laden des Events:', error);
                    showStatus('Fehler: ' + error.message, 'error');
                }
            } else {
                // Neues Event hinzufügen
                title.textContent = TEXT_CONFIG.addEventTitle;
                form.reset();
                document.getElementById('eventId').value = '';
            }
            
            modal.style.display = 'flex';
        }

        // Setup Recurrence Event Listeners
        function setupRecurrenceListeners() {
            const isRecurringCheckbox = document.getElementById('isRecurring');
            if (isRecurringCheckbox) {
                isRecurringCheckbox.addEventListener('change', function() {
                    toggleRecurrenceFields(this.checked);
                });
            }
        }

        // Recurrence Fields ein-/ausblenden
        function toggleRecurrenceFields(show) {
            const recurrenceFields = document.getElementById('recurrenceFields');
            if (recurrenceFields) {
                recurrenceFields.style.display = show ? 'block' : 'none';
            }
        }

        // Recurrence Settings laden
        async function loadRecurrenceSettings(taskId) {
            if (!db || !taskId) return;

            try {
                const result = db.exec('SELECT * FROM task_recurrences WHERE task_id = ? AND is_active = 1', [taskId]);
                if (result.length > 0 && result[0].values.length > 0) {
                    const recurrence = result[0].values[0];
                    const [id, taskId, isActive, intervalValue, intervalUnit, maxOccurrences, endDate] = recurrence;

                    document.getElementById('recurrenceId').value = id;
                    document.getElementById('isRecurring').checked = true;
                    document.getElementById('recurrenceInterval').value = intervalValue;
                    document.getElementById('recurrenceUnit').value = intervalUnit;
                    document.getElementById('maxOccurrences').value = maxOccurrences || '';
                    document.getElementById('endDate').value = endDate || '';

                    toggleRecurrenceFields(true);
                } else {
                    document.getElementById('recurrenceId').value = '';
                    document.getElementById('isRecurring').checked = false;
                    toggleRecurrenceFields(false);
                }
            } catch (error) {
                console.warn('Fehler beim Laden der Recurrence-Einstellungen:', error.message);
                // Fallback: normale Task ohne Recurrence
            }
        }
        
        // Task-Modal öffnen
        function openTaskModal(taskId = null) {
            const modal = document.getElementById('taskModal');
            const title = document.getElementById('taskModalTitle');
            const form = document.getElementById('taskForm');

            // Recurrence-Event-Listener setup
            setupRecurrenceListeners();

            if (taskId) {
                // Bestehenden Task bearbeiten
                title.textContent = TEXT_CONFIG.editTaskTitle;

                try {
                    // Lade Task-Daten
                    const result = db.exec('SELECT * FROM tasks WHERE id = ?', [taskId]);
                    if (result.length > 0) {
                        const task = result[0].values[0];
                        document.getElementById('taskId').value = task[0];
                        document.getElementById('eventType').value = task[1];
                        document.getElementById('taskType').value = task[2];
                        document.getElementById('taskDescription').value = task[3] || '';

                        const rangeValue = ['davor', 'am', 'danach'].includes(task[4]) ? task[4] : 'davor';
                        const value = !isNaN(parseFloat(task[5])) ? parseFloat(task[5]) : 1;
                        const unitValue = ['Tage', 'Wochen', 'Monate'].includes(task[6]) ? task[6] : 'Tage';
                        const sourceValue = task[7] || '';

                        setTimeout(() => {
                            const rangeSelect = document.getElementById('range');
                            const unitSelect = document.getElementById('unit');

                            if (rangeSelect) rangeSelect.value = rangeValue;
                            document.getElementById('value').value = value;
                            if (unitSelect) unitSelect.value = unitValue;
                            document.getElementById('source').value = sourceValue;

                            if (rangeSelect) rangeSelect.dispatchEvent(new Event('change'));
                            if (unitSelect) unitSelect.dispatchEvent(new Event('change'));
                        }, 0);

                        // Lade Recurrence-Daten falls vorhanden
                        loadRecurrenceSettings(taskId);
                    }
                } catch (error) {
                    console.error('Fehler beim Laden des Tasks:', error);
                    showStatus('Fehler: ' + error.message, 'error');
                }
            } else {
                // Neuen Task hinzufügen
                title.textContent = TEXT_CONFIG.addTaskTitle;
                form.reset();
                document.getElementById('taskId').value = '';
                document.getElementById('recurrenceId').value = '';
                document.getElementById('range').value = 'davor';
                document.getElementById('unit').value = 'Tage';

                // Recurrence-Felder ausblenden
                toggleRecurrenceFields(false);
            }

            modal.style.display = 'flex';
        }
        
        // Event speichern
        function saveEvent(e) {
            e.preventDefault();
            
            if (!db) {
                showStatus('Bitte zuerst eine Datenbank öffnen', 'error');
                return;
            }
            
            const id = document.getElementById('eventId').value;
            const eventName = document.getElementById('eventName').value;
            const date = document.getElementById('eventDate').value;
            const description = document.getElementById('eventDescription').value;
            
            try {
                if (id) {
                    // Event aktualisieren
                    db.run(
                        'UPDATE events SET event = ?, date = ?, description = ? WHERE id = ?',
                        [eventName, date, description, id]
                    );
                } else {
                    // Neues Event einfügen
                    db.run(
                        'INSERT INTO events (event, date, description) VALUES (?, ?, ?)',
                        [eventName, date, description]
                    );
                    // Erfolgsmeldung anzeigen
                    showStatus(TEXT_CONFIG.eventSaved, 'success');
                }
                
                saveDatabase(true); // Echte Datenänderung - Event gespeichert

                // Modal schließen
                document.getElementById('eventModal').style.display = 'none';

                // Events neu laden
                loadEvents();
                loadTodos();

                // Sync-Status aktualisieren
                updateSyncIndicator();

            } catch (error) {
                console.error('Fehler beim Speichern des Events:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }
        
        // Task speichern
        async function saveTask(e) {
            e.preventDefault();

            if (!db) {
                showStatus('Bitte zuerst eine Datenbank öffnen', 'error');
                return;
            }

            const id = document.getElementById('taskId').value;
            const recurrenceId = document.getElementById('recurrenceId').value;
            const eventType = document.getElementById('eventType').value;
            const taskType = document.getElementById('taskType').value;
            const taskDescription = document.getElementById('taskDescription').value;
            const range = document.getElementById('range').value;
            const value = document.getElementById('value').value;
            const unit = document.getElementById('unit').value;
            const source = document.getElementById('source').value;
            const isRecurring = document.getElementById('isRecurring').checked;

            try {
                let taskId = id;

                if (id) {
                    // Task aktualisieren
                    db.run(
                        'UPDATE tasks SET event_type = ?, task_type = ?, description = ?, range = ?, value = ?, unit = ?, source = ? WHERE id = ?',
                        [eventType, taskType, taskDescription, range, value, unit, source, id]
                    );
                } else {
                    // Neuen Task einfügen
                    const result = db.run(
                        'INSERT INTO tasks (event_type, task_type, description, range, value, unit, source) VALUES (?, ?, ?, ?, ?, ?, ?)',
                        [eventType, taskType, taskDescription, range, value, unit, source]
                    );
                    taskId = result.insertId;
                }

                // Recurrence-Daten verarbeiten
                if (isRecurring && taskId) {
                    await saveRecurrenceData(taskId, recurrenceId);
                } else if (recurrenceId && taskId) {
                    // Recurrence deaktivieren falls Checkbox nicht mehr aktiv
                    db.run('UPDATE task_recurrences SET is_active = 0 WHERE id = ?', [recurrenceId]);
                }

                saveDatabase(true); // Echte Datenänderung - Task gespeichert
                document.getElementById('taskModal').style.display = 'none';
                loadTasks();
                loadTodos();
                loadEvents(); // Event-Status aktualisieren
                loadEventTypes(); // Event-Types für Vorschläge aktualisieren
                showStatus(TEXT_CONFIG.taskSaved, 'success');

                // Sync-Status aktualisieren
                updateSyncIndicator();

            } catch (error) {
                console.error('Fehler beim Speichern des Task:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }

        // Recurrence-Daten speichern
        async function saveRecurrenceData(taskId, existingRecurrenceId) {
            const intervalValue = document.getElementById('recurrenceInterval').value;
            const intervalUnit = document.getElementById('recurrenceUnit').value;
            const maxOccurrences = document.getElementById('maxOccurrences').value || 0;
            const endDate = document.getElementById('endDate').value || null;

            try {
                if (existingRecurrenceId) {
                    // Bestehende Recurrence aktualisieren
                    db.run(`
                        UPDATE task_recurrences
                        SET interval_value = ?, interval_unit = ?, max_occurrences = ?, end_date = ?, updated_at = datetime('now')
                        WHERE id = ?
                    `, [intervalValue, intervalUnit, maxOccurrences, endDate, existingRecurrenceId]);
                } else {
                    // Neue Recurrence erstellen
                    db.run(`
                        INSERT INTO task_recurrences (task_id, interval_value, interval_unit, max_occurrences, end_date)
                        VALUES (?, ?, ?, ?, ?)
                    `, [taskId, intervalValue, intervalUnit, maxOccurrences, endDate]);
                }
            } catch (error) {
                console.error('Fehler beim Speichern der Recurrence-Daten:', error);
                throw error;
            }
        }
        
        // Event löschen
        async function deleteEvent(id) {
            if (!db) return;

            try {
                // 1. Daten des Events abrufen
                const eventData = db.exec('SELECT event FROM events WHERE id = ?', [id]);
                if (eventData.length === 0) return;

                const eventName = eventData[0].values[0][0];

                // 2. Prüfen auf unerledigte ToDos - BERÜCKSICHTIGE NUN WIEDERKEHRENDE INSTANZEN!
                let unfinishedCount = 0;

                const globalAllTodos = window.allTodos || allTodos;
                if (globalAllTodos && globalAllTodos.length > 0) {
                    // Verwende globale allTodos für korrekte Zählung (inkl. wiederkehrender Instanzen)
                    const eventTodos = globalAllTodos.filter(todo =>
                        todo.type === 'task' &&
                        todo.eventName === eventName &&
                        !todo.completed
                    );
                    unfinishedCount = eventTodos.length;

                    
                    // Event-Details für Bestätigung verfügbar
                } else {
                    // Fallback zu Datenbank-Query (ohne wiederkehrende Instanzen)

                    const unfinishedTodosQuery = `
                        SELECT COUNT(*) as count
                        FROM tasks t
                        WHERE t.event_type = ?
                        AND NOT EXISTS (
                            SELECT 1 FROM completed_tasks ct
                            WHERE ct.task_id = t.id AND ct.event_id = ?
                        )
                    `;
                    unfinishedCount = db.exec(unfinishedTodosQuery, [eventName, id])[0]?.values[0][0] || 0;
                }

                // 3. Mehrstufige Bestätigung
                let confirmationMessage = TEXT_CONFIG.confirmDeleteEvent;

                if (unfinishedCount > 0) {
                    const taskText = unfinishedCount === 1 ? "unerledigte Aufgabe" : "unerledigte Aufgaben";
                    confirmationMessage = `Achtung: Es gibt ${unfinishedCount} ${taskText} für dieses Ereignis. Diese werden unwiderruflich mitgelöscht.\n\n${TEXT_CONFIG.confirmDeleteEvent}`;
                }

                const confirmed = await customConfirm(confirmationMessage, "Ereignis löschen");
                if (!confirmed) return;

                // 4. Lösche wie bisher
                db.run('DELETE FROM completed_tasks WHERE event_id = ?', [id]);
                db.run('DELETE FROM events WHERE id = ?', [id]);

                saveDatabase(true); // Echte Datenänderung - Event gelöscht
                loadEvents();
                loadTodos();

                const successMessage = unfinishedCount > 0 ?
                    `Event gelöscht. ${unfinishedCount} unerledigte ToDo(s) wurden mitgelöscht.` :
                    TEXT_CONFIG.eventDeleted;

                showStatus(successMessage, 'success');

                // Sync-Status aktualisieren
                updateSyncIndicator();

            } catch (error) {
                console.error('Fehler beim Löschen des Events:', error);
                showStatus(TEXT_CONFIG.errorDeletingEvent + ': ' + error.message, 'error');
            }
        }
        
        // Task duplizieren
        function duplicateTask(id) {
            if (!db) return;
            
            try {
                // Task-Daten abrufen
                const result = db.exec('SELECT * FROM tasks WHERE id = ?', [id]);
                if (result.length === 0 || result[0].values.length === 0) {
                    throw new Error('Task nicht gefunden');
                }
                
                const task = result[0].values[0];
                const [_, eventType, taskType, description, range, value, unit, source] = task;
                
                // Neuen Task mit kopierten Werten erstellen
                db.run(
                    'INSERT INTO tasks (event_type, task_type, description, range, value, unit, source) VALUES (?, ?, ?, ?, ?, ?, ?)',
                    [eventType, taskType, description, range, value, unit, source]
                );
                
                saveDatabase(true); // Echte Datenänderung - Task dupliziert
                loadTasks();
                loadTodos();
                loadEvents(); // Event-Status aktualisieren, falls nötig
                showStatus('Aufgabe erfolgreich dupliziert', 'success');

                // Sync-Status aktualisieren
                updateSyncIndicator();

            } catch (error) {
                console.error('Fehler beim Duplizieren der Aufgabe:', error);
                showStatus('Fehler: ' + error.message, 'error');
            }
        }
        
        // Task löschen
        async function deleteTask(id) {
            if (!db) return;

            const confirmed = await customConfirm(TEXT_CONFIG.confirmDeleteTask, "Aufgabe löschen");
            if (!confirmed) return;

            try {
                // Prüfe, ob es sich um einen wiederkehrenden Task handelt
                const recurrenceResult = db.exec('SELECT id FROM task_recurrences WHERE task_id = ?', [id]);
                const isRecurring = recurrenceResult.length > 0;

                let additionalMessage = '';
                if (isRecurring) {
                    // Zähle alle erledigten Instanzen für wiederkehrende Tasks - ROBUST für alte DBs
                    let completedCount = 0;
                    try {
                        const completedInstancesResult = db.exec(
                            'SELECT COUNT(*) as count FROM completed_tasks WHERE task_id = ? AND occurrence_date IS NOT NULL',
                            [id]
                        );
                        completedCount = completedInstancesResult.length > 0 ? completedInstancesResult[0].values[0][0] : 0;
                    } catch (error) {

                        // Fallback: Zähle alle Instanzen für diesen Task (alte DBs ohne occurrence_date)
                        try {
                            const fallbackResult = db.exec(
                                'SELECT COUNT(*) as count FROM completed_tasks WHERE task_id = ?',
                                [id]
                            );
                            completedCount = fallbackResult.length > 0 ? fallbackResult[0].values[0][0] : 0;
                        } catch (fallbackError) {
                            console.error('❌ Auch Fallback-Zählung fehlgeschlagen:', fallbackError);
                            completedCount = 0;
                        }
                    }

                    if (completedCount > 0) {
                        additionalMessage = `\n\nHinweis: ${completedCount} erledigte Instanzen dieses wiederkehrenden Tasks werden ebenfalls gelöscht.`;
                    }
                }

                // Zweite Bestätigung wenn zusätzliche Informationen vorhanden sind
                if (additionalMessage) {
                    const finalConfirmation = await customConfirm(
                        TEXT_CONFIG.confirmDeleteTask + additionalMessage,
                        "Aufgabe und Instanzen löschen"
                    );
                    if (!finalConfirmation) return;
                }

                // ENTFERNE In dieser Reihenfolge um Fremdschlüsselverletzungen zu vermeiden
                // 1. Alle completion-Einträge (inkl. wiederkehrender Instanzen)
                db.run('DELETE FROM completed_tasks WHERE task_id = ?', [id]);

                // 2. Calendar-Todos
                db.run('DELETE FROM calendar_todos WHERE task_id = ?', [id]);

                // 3. Recurrence-Einstellungen (CASCADE löscht automatisch)
                db.run('DELETE FROM task_recurrences WHERE task_id = ?', [id]);

                // 4. Task selbst
                db.run('DELETE FROM tasks WHERE id = ?', [id]);

                saveDatabase(true); // Echte Datenänderung - Task gelöscht
                loadTasks();
                loadTodos();
                loadEvents(); // Event-Status aktualisieren
                loadEventTypes(); // Event-Types für Vorschläge aktualisieren
                showStatus(TEXT_CONFIG.taskDeleted, 'success');

            } catch (error) {
                console.error('Fehler beim Löschen der Aufgabe:', error);
                showStatus(TEXT_CONFIG.errorDeletingTask + ': ' + error.message, 'error');
            }
        }
        
        // Statusmeldung anzeigen
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;

            setTimeout(() => {
                statusEl.textContent = '';
                statusEl.className = 'status';
            }, 3000);
        }

        // Filter-Funktionen für Todo-Liste
        function setupTodoFilter() {
            // Event-Listener für Filter-Buttons hinzufügen (nur Todo-Tab)
            const filterButtons = document.querySelectorAll('#todosTab .filter-btn');
            filterButtons.forEach(button => {
                button.addEventListener('click', toggleFilter);
            });

            updateFilterButtonStates();
            applyTodoFilters();
            updateTodoCounts(); // Anzahl der Aufgaben aktualisieren
        }

        function toggleFilter() {
            const filterType = this.dataset.filter;

            // Filter umschalten
            if (activeFilters.includes(filterType)) {
                // Filter entfernen
                activeFilters = activeFilters.filter(filter => filter !== filterType);
                this.classList.remove('active');
            } else {
                // Filter hinzufügen
                activeFilters.push(filterType);
                this.classList.add('active');
            }

            applyTodoFilters();
        }

        function getTodoStatusClass(todo) {
            if (todo.type === 'event') {
                return 'event';
            }

            if (todo.completed) {
                return 'erledigt';
            }

            const urgencyClass = getDeadlineUrgencyClass(todo.deadline, false);

            switch (urgencyClass) {
                case 'deadline-overdue':
                    return 'ueberfaellig';
                case 'deadline-normal':
                    return 'offen';
                case 'deadline-critical':
                case 'deadline-warning':
                case 'deadline-soon':
                    return 'anstehend';
                default:
                    return 'offen';
            }
        }

        function applyTodoFilters() {
            const todoItems = document.querySelectorAll('.todo-item');

            todoItems.forEach(item => {
                const li = item.closest('li');
                if (!li) return;

                let shouldShow = false;

                // Prüfen, ob es eine .todo-main Klasse gibt (normale Todo)
                const todoMain = item.querySelector('.todo-main');
                if (todoMain) {
                    // Normale Todo - Status ermitteln
                    const todoText = todoMain.textContent;

                    // Status basierend auf verschiedenen Indikatoren ermitteln
                    let todoStatus = 'offen'; // Standard

                    if (item.classList.contains('no-tasks-warning')) {
                        todoStatus = 'event'; // Event ohne Tasks
                    } else if (item.classList.contains('completed')) {
                        todoStatus = 'erledigt';
                    } else {
                        // Basierend auf deadline-Klassen ermitteln
                        const deadlineElement = item.querySelector('[class*="deadline-"]');
                        if (deadlineElement) {
                            if (deadlineElement.classList.contains('deadline-overdue')) {
                                todoStatus = 'ueberfaellig';
                            } else if (deadlineElement.classList.contains('deadline-normal')) {
                                todoStatus = 'offen';
                            } else {
                                todoStatus = 'anstehend';
                            }
                        }
                    }

                    // Prüfen, ob dieser Status in den aktiven Filtern ist
                    shouldShow = activeFilters.includes(todoStatus) ||
                               (todoStatus === 'event' && activeFilters.length === 0); // Events immer anzeigen wenn keine Filter aktiv
                } else {
                    // Andere Elemente immer anzeigen
                    shouldShow = true;
                }

                // Anzeige umschalten
                if (shouldShow) {
                    item.style.display = '';
                    li.style.display = '';
                } else {
                    item.style.display = 'none';
                    li.style.display = 'none';
                }
            });
        }

        function updateFilterButtonStates() {
            // Button-Zustände basierend auf aktiven Filtern aktualisieren
            document.querySelectorAll('.filter-btn').forEach(button => {
                const filterType = button.dataset.filter;
                if (activeFilters.includes(filterType)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // Anzahl der Aufgaben mit neuer Kategorisierung aktualisieren
        function updateTodoCounts() {
            if (!todoCounts) return;

            try {
                // Zählungen aus globaler Variable verwenden (berechnet in loadTodos)
                const completedCount = todoCounts.erledigt || 0;
                const anstCount = todoCounts.anstehend || 0;
                const offenCount = todoCounts.offen || 0;
                const ueberfaelligCount = todoCounts.ueberfaellig || 0;

                // Zählungen aktualisiert

                // Button-Elemente aktualisieren
                const filterErledigt = document.getElementById('filter-erledigt');
                const filterAnstehend = document.getElementById('filter-anstehend');
                const filterOffen = document.getElementById('filter-offen');
                const filterUeberfaellig = document.getElementById('filter-ueberfaellig');

                if (filterErledigt) filterErledigt.textContent = `${completedCount} Erledigt`;
                if (filterAnstehend) filterAnstehend.textContent = `${anstCount} Anstehend`;
                if (filterOffen) filterOffen.textContent = `${offenCount} Offen`;
                if (filterUeberfaellig) filterUeberfaellig.textContent = `${ueberfaelligCount} Überfällig`;

            } catch (error) {
                console.error('Fehler beim Aktualisieren der Todo-Anzahl:', error);
            }
        }

        // Custom Confirmation Modal Helper Function
        function customConfirm(message, title = "Bestätigung") {
            return new Promise((resolve) => {
                // Modal füllen und öffnen
                document.getElementById('confirmModalTitle').textContent = title;
                document.getElementById('confirmModalMessage').innerHTML = message;
                document.getElementById('confirmModal').style.display = 'flex';

                // Event-Listener für Buttons
                const confirmBtn = document.getElementById('confirmBtn');
                const cancelBtn = document.getElementById('cancelBtn');
                const closeBtn = document.getElementById('confirmModalClose');

                const complete = (result) => {
                    document.getElementById('confirmModal').style.display = 'none';
                    // Event-Listener entfernen
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    closeBtn.removeEventListener('click', cancelHandler);
                    resolve(result);
                };

                const confirmHandler = () => complete(true);
                const cancelHandler = () => complete(false);

                confirmBtn.addEventListener('click', confirmHandler);
                cancelBtn.addEventListener('click', cancelHandler);
                closeBtn.addEventListener('click', cancelHandler);
            });
        }

        // Event-Listener für Bestätigungs-Modal
        document.getElementById('confirmModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('confirmModal')) {
                document.getElementById('confirmModal').style.display = 'none';
            }
        });

        // Event-Listener für Server-Config-Modal
        document.getElementById('serverConfigForm').addEventListener('submit', saveServerConfig);

        // ============================
        // SERVER-SERVER-KONFIGURATION UND SYNC-FUNKTIONEN
        // ============================

        // Server-Konfiguration öffnen
        function openServerConfigModal() {
            if (!db) {
                showStatus('Datenbank nicht verfügbar', 'error');
                return;
            }

            try {
                // Bestehende Konfiguration laden
                const serverUrlResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'server_url'
                `);
                const userUidResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'user_uid'
                `);
                const encryptionKeyResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'encryption_key'
                `);

                const serverUrl = serverUrlResult.length > 0 ? serverUrlResult[0].values[0][0] : '';
                const userUid = userUidResult.length > 0 ? userUidResult[0].values[0][0] : '';
                const encryptionKey = encryptionKeyResult.length > 0 ? encryptionKeyResult[0].values[0][0] : '';

                document.getElementById('serverUrl').value = serverUrl;
                document.getElementById('userUid').value = userUid;
                document.getElementById('encryptionKey').value = encryptionKey;

                // Password Toggle Setup
                const toggleBtn = document.getElementById('toggleEncryptionKey');
                const passwordInput = document.getElementById('encryptionKey');
                if (toggleBtn && passwordInput) {
                    toggleBtn.addEventListener('click', function() {
                        const isCurrentlyPassword = passwordInput.type === 'password';
                        passwordInput.type = isCurrentlyPassword ? 'text' : 'password';
                        toggleBtn.textContent = isCurrentlyPassword ? '🙈' : '👁️';
                        toggleBtn.title = isCurrentlyPassword ? 'Passwort verstecken' : 'Passwort anzeigen';
                    });
                }

                // Aktuelle Geräte-Namen laden und anzeigen
                const currentFingerprint = getDeviceFingerprint();
                document.getElementById('currentNameDisplay').textContent = currentFingerprint;

                // Falls bereits ein benutzerdefinierter Name existiert, diesen im Eingabefeld anzeigen
                const customName = localStorage.getItem('customDeviceName') || '';
                document.getElementById('deviceName').value = customName;

                document.getElementById('serverConfigModal').style.display = 'flex';
            } catch (error) {
                console.error('Fehler beim Laden der Server-Konfiguration:', error);
                showStatus('Fehler beim Laden der Konfiguration', 'error');
            }
        }

        // Server-Konfiguration schließen
        function closeServerConfigModal() {
            document.getElementById('serverConfigModal').style.display = 'none';
        }

        // Server-Konfiguration speichern
        function saveServerConfig(e) {
            e.preventDefault();

            if (!db) {
                showStatus('Datenbank nicht verfügbar', 'error');
                return;
            }

            const serverUrl = document.getElementById('serverUrl').value;
            const userUid = document.getElementById('userUid').value;
            const deviceName = document.getElementById('deviceName').value.trim();
            const encryptionKey = document.getElementById('encryptionKey').value.trim();

            try {
                // Server-Konfiguration in Metadata speichern
                db.run(`
                    INSERT OR REPLACE INTO metadata (key, value, updated_at)
                    VALUES ('server_url', ?, datetime('now'))
                `, [serverUrl]);

                db.run(`
                    INSERT OR REPLACE INTO metadata (key, value, updated_at)
                    VALUES ('user_uid', ?, datetime('now'))
                `, [userUid]);

                // Verschlüsselungs-Key speichern (leer = keine Verschlüsselung)
                if (encryptionKey) {
                    db.run(`
                        INSERT OR REPLACE INTO metadata (key, value, updated_at)
                        VALUES ('encryption_key', ?, datetime('now'))
                    `, [encryptionKey]);
                } else {
                    // Falls leer, Eintrag entfernen (nicht speichern)
                    db.run(`
                        DELETE FROM metadata WHERE key = 'encryption_key'
                    `);
                }

                // Benutzerdefinierten Geräte-Namen verwalten
                if (deviceName) {
                    // Benutzerdefinierter Name gesetzt
                    setCustomDeviceName(deviceName);
                } else {
                    // Leerer String - zurück zum automatisch generierten Namen
                    localStorage.removeItem('customDeviceName');
                    // Cache für auto-generierten Namen leeren, damit neu generiert wird
                    localStorage.removeItem('autoDeviceName');
                }

                saveDatabase();
                closeServerConfigModal();
                showStatus('Server-Konfiguration gespeichert', 'success');

                // Sync-Status aktualisieren (neue Konfiguration)
                updateSyncIndicator();

                // Kontakt-Button-Sichtbarkeit aktualisieren
                updateContactVisibility();
            } catch (error) {
                console.error('Fehler beim Speichern der Server-Konfiguration:', error);
                showStatus('Fehler beim Speichern der Konfiguration', 'error');
            }
        }

        // Hilfsfunktion: Verschlüsselungs-Key laden (null wenn keiner gesetzt)
        function getEncryptionKey() {
            if (!db) return null;

            try {
                const result = db.exec(`
                    SELECT value FROM metadata WHERE key = 'encryption_key'
                `);
                return result.length > 0 ? result[0].values[0][0] : null;
            } catch (error) {
                return null;
            }
        }

        // Hilfsfunktion: Server-Konfiguration laden
        function getServerConfig() {
            if (!db) return null;

            try {
                const serverUrlResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'server_url'
                `);

                const userUidResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'user_uid'
                `);

                const serverUrl = serverUrlResult.length > 0 ? serverUrlResult[0].values[0][0] : '';
                const userUid = userUidResult.length > 0 ? userUidResult[0].values[0][0] : '';

                if (!serverUrl || !userUid) {
                    return null;
                }

                return {
                    url: serverUrl,
                    uid: userUid
                };
            } catch (error) {
                return null;
            }
        }

        // Kontakt-Button-Sichtbarkeit basierend auf Server-Konfiguration aktualisieren
        function updateContactVisibility() {
            const config = getServerConfig();
            const contactBtn = document.getElementById('contactBtn');
            if (contactBtn) {
                contactBtn.style.display = config ? 'block' : 'none';
            }
        }

        // Check Sync Status - Hauptlogik für halbautomatisches Sync
        async function checkSyncStatus() {
            const config = getServerConfig();
            if (!config) return { status: 'no_config', action: null };

            try {
                // Lokale Daten prüfen
                const localChangeResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'last_local_change'
                `);
                const localLastChange = localChangeResult.length > 0 ? localChangeResult[0].values[0][0] : null;

                const localSyncResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'last_sync_time'
                `);
                const lastSync = localSyncResult.length > 0 ? localSyncResult[0].values[0][0] : null;

                // Server prüfen (leichte Anfrage)
                const payload = {
                    action: 'download',
                    uid: config.uid
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    return { status: 'server_error', action: null, message: `HTTP ${response.status}` };
                }

                const result = await response.json();

                if (!result.success) {
                    return { status: 'server_error', action: null, message: result.message };
                }

                if (!result.data) {
                    return { status: 'server_no_data', action: 'upload', message: 'Keine Daten auf Server' };
                }

                const serverTimestamp = result.data.timestamp;
                const serverTime = new Date(serverTimestamp).getTime(); // Sicherstellen, dass es ein Timestamp ist
                const localTime = localLastChange ? new Date(localLastChange).getTime() : null;
                const syncTime = lastSync ? new Date(lastSync).getTime() : 0;
                const serverFingerprint = result.deviceFingerprint || 'Unbekannt'; // Server-Fingerprint extrahieren

                // Entscheidungslogik verbessert:
                // - Wenn keine lokalen Änderungen seit letztem Sync -> synchronisiert
                // - Wenn Server neuer als letzter Sync -> Download nötig
                // - Wenn lokale Änderungen vorhanden seit letztem Sync -> Upload nötig
                // - Beide neuer -> Konflikt

                if (!localTime || localTime <= syncTime) {
                    // Keine lokalen Änderungen seit letztem Sync
                    if (serverTime > syncTime) {
                        
                        return { status: 'download_needed', action: 'download', message: 'Server hat neuere Daten', serverFingerprint: serverFingerprint };
                    } else {
                        
                        return { status: 'synced', action: null, message: 'Daten sind synchronisiert', serverFingerprint: serverFingerprint };
                    }
                } else {
                    // Lokale Änderungen vorhanden
                    if (serverTime <= syncTime) {
                        
                        return { status: 'upload_needed', action: 'upload', message: 'Lokale Änderungen vorhanden', serverFingerprint: serverFingerprint };
                    } else {
                        // Beide haben geänderte Daten
                        
                        return { status: 'conflict', action: 'choose', message: 'Lokale und Server-Änderungen vorhanden', serverFingerprint: serverFingerprint };
                    }
                }

            } catch (error) {
                console.error('Fehler bei Sync-Status-Prüfung:', error);
                return { status: 'error', action: null, message: error.message };
            }
        }

        // Update Sync Indicator UI
        async function updateSyncIndicator(syncResult = null) {
            const config = getServerConfig();
            const indicator = document.getElementById('syncIndicator');
            const statusSpan = document.getElementById('syncStatus');
            const manualBtn = document.getElementById('manualSyncBtn');

            // Keine Server-Konfiguration -> ausblenden
            if (!config) {
                if (indicator) indicator.style.display = 'none';
                return;
            }

            // Indicator anzeigen
            if (indicator) indicator.style.display = 'flex';

            // NEU: Prüfe, ob Sync vorübergehend deaktiviert ist
            const now = Date.now();
            if (syncSuggestionDisabledUntil && now < syncSuggestionDisabledUntil) {
                // Zeige Status, aber keine automatischen Aktionen
                statusText = 'Download manuell verfügbar';
                statusSpan.classList.add('download-needed');
                if (manualBtn) {
                    manualBtn.style.display = 'inline-flex';
                    manualBtn.textContent = '⬇️';
                    manualBtn.title = 'Download manuell starten';
                }
                // Status-Text setzen und vorzeitig zurückkehren
                if (statusSpan) statusSpan.textContent = statusText;
                return;
            }

            // Wenn kein Status übergeben, selbst prüfen
            if (!syncResult) {
                syncResult = await checkSyncStatus();
            }

            // Status-Text und CSS-Klass setzen
            statusSpan.className = 'sync-status'; // Reset classes

            let statusText = '';
            let actionFunction = null;

            switch(syncResult.status) {
                case 'synced':
                    statusText = 'Synchronisiert  ✅';
                    statusSpan.classList.add('synced');
                    if (manualBtn) manualBtn.style.display = 'none';
                    break;

                case 'upload_needed':
                    statusText = 'Upload nötig';
                    statusSpan.classList.add('upload-needed');
                    actionFunction = () => uploadDatabaseToServer();
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-flex';
                        manualBtn.textContent = '⬆️';
                        manualBtn.title = 'Upload zur Datenbank';
                    }
                    // AUTOMATISCHER UPLOAD: Nach kurzer Verzögerung automatisch ausführen
                    setTimeout(async () => {
                        try {
                            await uploadDatabaseToServer();
                            setTimeout(() => updateSyncIndicator(), 1000);
                        } catch (error) {
                            console.error('Automatischer Upload fehlgeschlagen:', error);
                        }
                    }, 500); // 500ms Verzögerung für bessere UX
                    break;

                case 'download_needed':
                    statusText = 'Download nötig';
                    statusSpan.classList.add('download-needed');
                    actionFunction = () => downloadDatabaseFromServer();
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-flex';
                        manualBtn.textContent = '⬇️';
                        manualBtn.title = 'Download vom Server';
                    }
                    // AUTOMATISCHER DOWNLOAD: Nach kurzer Verzögerung automatisch ausführen
                    setTimeout(async () => {
                        // NEU: Vor Automatik: Prüfe Deaktivierung
                        if (syncSuggestionDisabledUntil && Date.now() < syncSuggestionDisabledUntil) {
                            return;
                        }
                        try {
                            await downloadDatabaseFromServer(true);  // Automatisch ohne Bestätigung ➜ (true) / mit Nachfrage ➜ ()
                            setTimeout(() => updateSyncIndicator(), 1000);
                        } catch (error) {
                            console.error('Automatischer Download fehlgeschlagen:', error);
                        }
                    }, 500); // 500ms Verzögerung für bessere UX
                    break;

                case 'conflict':
                    statusText = 'Konflikt lösen';
                    statusSpan.classList.add('conflict');
                    actionFunction = () => showConflictResolution(syncResult);
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-flex';
                        manualBtn.textContent = '⚡';
                        manualBtn.title = 'Konflikt lösen';
                    }
                    // KEIN automatischer Konflikt-Resolve - Benutzer muss manuell entscheiden
                    break;

                case 'server_no_data':
                    statusText = '🆕 Server leer';
                    statusSpan.classList.add('upload-needed');
                    actionFunction = () => confirmNoServerDataUpload();
                    if (manualBtn) {
                        manualBtn.style.display = 'inline-flex';
                        manualBtn.textContent = '⬆️';
                        manualBtn.title = 'Ersten Upload';
                    }
                    // AUTOMATISCHER ERSTER UPLOAD: Nach kurzer Verzögerung automatisch ausführen
                    setTimeout(async () => {
                        try {
                            await confirmNoServerDataUpload();
                            setTimeout(() => updateSyncIndicator(), 1000);
                        } catch (error) {
                            console.error('Automatischer erster Upload fehlgeschlagen:', error);
                        }
                    }, 500); // 500ms Verzögerung für bessere UX
                    break;

                case 'error':
                case 'server_error':
                    statusText = '❌ Sync-Fehler';
                    statusSpan.classList.add('error');
                    if (manualBtn) manualBtn.style.display = 'none';
                    break;

                default:
                    statusText = '🔄 Status prüfen...';
                    if (manualBtn) manualBtn.style.display = 'none';
            }

            // Status-Text setzen
            if (statusSpan) {
                statusSpan.textContent = statusText;
            }

            // Manuelle Sync-Event-Listener setzen (für Fallback und manuelle Steuerung)
            if (manualBtn && actionFunction && manualBtn.parentNode) {
                // Entferne zuerst bestehende Event-Listener
                const existingBtn = manualBtn;
                const newManualBtn = existingBtn.cloneNode(true);

                existingBtn.parentNode.replaceChild(newManualBtn, existingBtn);
                newManualBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    await actionFunction();
                    // Nach Aktion Status neu prüfen
                    setTimeout(() => updateSyncIndicator(), 1000);
                });
            }

        }

        // Konflikt-Auflösung anzeigen
        async function showConflictResolution(syncResult) {
            const localFingerprint = getDeviceFingerprint();
            const serverResult = syncResult.serverFingerprint || 'Unbekannt';
            
            const confirmed = await customConfirm(
                `Konflikt entdeckt: Sowohl lokale (${localFingerprint}) als auch Server-Änderungen vorhanden.\n\nWie möchtest du fortfahren?`,
                "Sync-Konflikt lösen",
                [
                    { id: 'upload', text: `Lokale Änderungen behalten (${localFingerprint})`, class: 'btn btn-primary' },
                    { id: 'download', text: `Server-Daten übernehmen (${serverResult})`, class: 'btn btn-outline' },
                    { id: 'merge', text: 'Automatische Auswahl', class: 'btn btn-secondary', title: 'Automatische Auswahl: Überprüft Zeitstempel und entscheidet' }
                ]
            );
            
            if (!confirmed || !confirmed.action) return;
            
            switch(confirmed.action) {
                case 'upload':
                    await uploadDatabaseToServer();
                    break;
                case 'download':
                    const confirmDownload = await customConfirm(
                        `Lokale Änderungen (${localFingerprint}) werden überschrieben. Server (${serverResult}) hat Vorrang.\n\nFortfahren?`,
                        'Server-Daten übernehmen',
                        null
                    );
                    if (confirmDownload) await downloadDatabaseFromServer(true); // true = überschreibe lokale Daten ohne weitere Nachfrage
                    break;
                case 'merge':
                    await intelligentMerge();
                    break;
            }
            
            setTimeout(() => updateSyncIndicator(), 1000);
        }

        // Hilfsfunktion: Keine Server-Daten-Upload bestätigen
        async function confirmNoServerDataUpload() {
            const confirmed = await customConfirm(
                'Server hat keine Daten. Möchtest du deine lokalen Daten als erste Datenbank hochladen?',
                'Ersten Upload bestätigen'
            );

            if (confirmed) {
                await uploadDatabaseToServer();
                setTimeout(() => updateSyncIndicator(), 1000);
            }
        }

        // Intelligenter Merge-Versuch
        async function intelligentMerge() {
            const config = getServerConfig();
            if (!config) return;

            try {
                showStatus('🔄 Merge wird vorbereitet...', 'info');

                // Hole Server-Daten ohne lokale Überschreibung
                const payload = { action: 'download', uid: config.uid };
                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                if (!result.success || !result.data) {
                    throw new Error('Keine Server-Daten gefunden');
                }

                // Deserialisiere Server-Daten für Vergleich
                const serverData = await deserializeDatabaseFromJSON(result.data);
                const serverDB = serverData.db;

                // Hole Server- und lokale Zeitstempel für Vergleich
                const lastSyncResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'last_sync_time'
                `);
                const lastSyncTime = lastSyncResult.length > 0 ? lastSyncResult[0].values[0][0] : null;

                // Hole letzte lokale Änderung
                const lastLocalChangeResult = db.exec(`
                    SELECT value FROM metadata WHERE key = 'last_local_change'
                `);
                const lastLocalChangeTime = lastLocalChangeResult.length > 0 ? lastLocalChangeResult[0].values[0][0] : null;

                // Überprüfe, ob lokale Änderungen seit letztem Sync vorhanden sind
                const hasLocalChanges = lastLocalChangeTime && lastSyncTime &&
                                        new Date(lastLocalChangeTime) > new Date(lastSyncTime);

                if (hasLocalChanges) {
                    // Lokale Änderungen vorhanden - Upload bevorzugen
                    showStatus('Lokale Änderungen erkannt - Upload wird vorgeschlagen', 'info');
                    await uploadDatabaseToServer();
                } else {
                    // Keine lokalen Änderungen - einfach neu laden
                    showStatus('Server-Version wird übernommen', 'info');
                    await downloadDatabaseFromServer();
                }

            } catch (error) {
                console.error('Merge fehlgeschlagen:', error);
                showStatus('Merge fehlgeschlagen: ' + error.message, 'error');

                // Fallback: Zeige manuelle Optionen
                await showConflictResolution({ status: 'conflict' });
            }
        }

        // ============================
        // GERAETE-FINGERPRINT FUNKTIONEN
        // ============================

        // Benutzerfreundlichen Geräte-Namen generieren und cachen
        function getDeviceFingerprint() {
            // Versuche zuerst, einen benutzerdefinierten Namen zu laden
            let customName = localStorage.getItem('customDeviceName');
            if (customName) {
                return customName;
            }

            // Versuche, einen gecachten automatisch generierten Namen zu laden
            let cachedName = localStorage.getItem('autoDeviceName');
            if (cachedName) {
                return cachedName;
            }

            // Erstelle neuen benutzerfreundlichen Geräte-Namen
            const deviceName = generateDeviceName();

            // Speichere den automatisch generierten Namen
            localStorage.setItem('autoDeviceName', deviceName);

            return deviceName;
        }

        // Benutzerfreundlichen Geräte-Namen basierend auf Browser/Eigenschaften generieren
        function generateDeviceName() {
            const userAgent = navigator.userAgent.toLowerCase();

            // Basis-Name aus Browser-Typ ermitteln
            let deviceType = "Unbekannt";

            if (userAgent.includes('chrome') && !userAgent.includes('edg')) {
                deviceType = "Chrome";
            } else if (userAgent.includes('firefox')) {
                deviceType = "Firefox";
            } else if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
                deviceType = "Safari";
            } else if (userAgent.includes('edg')) {
                deviceType = "Edge";
            } else if (userAgent.includes('opera')) {
                deviceType = "Opera";
            }

            // Betriebssystem hinzufügen
            let os = "";
            if (userAgent.includes('windows')) {
                os = " Windows";
            } else if (userAgent.includes('mac')) {
                os = " macOS";
            } else if (userAgent.includes('linux')) {
                os = " Linux";
            } else if (userAgent.includes('android')) {
                os = " Android";
            } else if (userAgent.includes('ios')) {
                os = " iOS";
            }

            // Wenn es sich um ein mobiles Gerät handelt
            const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
            if (isMobile) {
                deviceType = "Mobile " + deviceType;
            }

            // Kombiniere zu einem lesbaren Namen
            const fullName = deviceType + os;

            // Hänge zufällige Endung für Eindeutigkeit hinzu
            const randomSuffix = Math.random().toString(36).substring(2, 5).toUpperCase();
            return `${fullName} (${randomSuffix})`;
        }

        // Funktion zum Setzen eines benutzerdefinierten Geräte-Namens
        function setCustomDeviceName(name) {
            if (name && name.trim()) {
                localStorage.setItem('customDeviceName', name.trim());
                showStatus(`Geräte-Name geändert zu: ${name.trim()}`, 'success');
                return true;
            } else {
                showStatus('Ungültiger Geräte-Name', 'error');
                return false;
            }
        }

        // Funktion zum Zurücksetzen auf automatisch generierten Namen
        function resetToAutoDeviceName() {
            localStorage.removeItem('customDeviceName');
            localStorage.removeItem('autoDeviceName'); // Erzwingt Neugenerierung
            const newName = getDeviceFingerprint();
            showStatus(`Geräte-Name zurückgesetzt zu: ${newName}`, 'success');
            return newName;
        }

        // Einfache Hash-Funktion für technische Zwecke (falls noch benötigt)
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash).toString(36).substr(0, 8).toUpperCase();
        }

        // Erweitere customConfirm für mehrere Optionen
        function customConfirm(message, title = "Bestätigung", options = null) {
            return new Promise((resolve) => {
                // Modal füllen und öffnen
                document.getElementById('confirmModalTitle').textContent = title;
                document.getElementById('confirmModalMessage').textContent = message; // Verwende textContent statt innerHTML

                const messageDiv = document.getElementById('confirmModalMessage');

                // Entferne vorherige dynamische Buttons
                const existingButtonsContainer = messageDiv.querySelector('div[style*="text-align"]');
                if (existingButtonsContainer) {
                    existingButtonsContainer.remove();
                }

                // Hole Referenzen zu den Standard-Buttons
                const confirmBtn = document.getElementById('confirmBtn');
                const cancelBtn = document.getElementById('cancelBtn');
                const closeBtn = document.getElementById('confirmModalClose');

                // Entferne alle vorherigen Event-Listener (wichtig!)
                const newConfirmBtn = confirmBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

                const newCloseBtn = closeBtn.cloneNode(true);
                closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

                const complete = (result) => {
                    document.getElementById('confirmModal').style.display = 'none';
                    resolve(result);
                };

                // Wenn Optionen gegeben, ersetze Standard-Buttons
                if (options && Array.isArray(options) && options.length > 0) {
                    // Blende Standard-Buttons aus
                    newConfirmBtn.style.display = 'none';
                    newCancelBtn.style.display = 'none';

                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.style.textAlign = 'center';
                    buttonsContainer.style.marginTop = '15px';

                    options.forEach(option => {
                        const button = document.createElement('button');
                        button.textContent = option.text;
                        button.className = option.class || 'btn btn-primary';
                        button.style.margin = '5px';
                        button.onclick = () => {
                            complete({ confirmed: true, action: option.id });
                        };
                        buttonsContainer.appendChild(button);
                    });

                    messageDiv.appendChild(buttonsContainer);

                    // Close-Handler für Cancel über Modal-selbst
                    newCloseBtn.onclick = () => complete({ confirmed: false });
                } else {
                    // Zeige Standard-Buttons an
                    newConfirmBtn.style.display = 'inline-block';
                    newCancelBtn.style.display = 'inline-block';
                    newConfirmBtn.textContent = 'Ja';
                    newCancelBtn.textContent = 'Nein';

                    // Setze Event-Listener für Standard-Buttons
                    newConfirmBtn.onclick = () => complete(true);
                    newCancelBtn.onclick = () => complete(false);
                    newCloseBtn.onclick = () => complete(false);
                }

                // Modal öffnen
                document.getElementById('confirmModal').style.display = 'flex';
            });
        }

        // ============================
        // VERSCHLÜSSELUNGSFUNKTIONEN
        // ============================

        // Key aus Passwort ableiten (PBKDF2 für AES-GCM)
        async function deriveEncryptionKey(password, salt = null) {
            if (!salt) {
                // Generiere zufälligen Salt falls keiner übergeben
                salt = crypto.getRandomValues(new Uint8Array(16));
            }

            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );

            return { key, salt };
        }

        // Daten verschlüsseln
        async function encryptData(data, password) {
            const { key, salt } = await deriveEncryptionKey(password);

            const encoder = new TextEncoder();
            const encodedData = encoder.encode(data);

            // Generiere zufälligen Initialisierungsvektor (IV)
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                encodedData
            );

            // Kombiniere Salt + IV + verschlüsselte Daten
            const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
            result.set(salt, 0);
            result.set(iv, salt.length);
            result.set(new Uint8Array(encrypted), salt.length + iv.length);

            // Base64 für JSON-Transport
            return btoa(String.fromCharCode.apply(null, result));
        }

        // Daten entschlüsseln
        async function decryptData(encryptedData, password) {
            try {
                // Base64 dekodieren
                const combined = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));

                // Extrahiere Salt (16 Bytes), IV (12 Bytes) und verschlüsselte Daten
                const salt = combined.slice(0, 16);
                const iv = combined.slice(16, 28);
                const encrypted = combined.slice(28);

                // Key ableiten
                const { key } = await deriveEncryptionKey(password, salt);

                // Entschlüsseln
                const decrypted = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encrypted
                );

                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                throw new Error('Verschlüsselung-Schlüssel ist falsch oder Daten sind beschädigt');
            }
        }

        // Hilfsfunktion: Datenbank als JSON serialisieren
        async function serializeDatabaseAsJSON() {
            if (!db) return null;

            try {
                const data = db.export();
                let base64 = arrayBufferToBase64(data);
                const timestamp = new Date().toISOString();
                let isEncrypted = false;

                // Prüfen, ob Verschlüsselung aktiviert ist
                const encryptionKey = getEncryptionKey();
                if (encryptionKey) {
                    try {
                        base64 = await encryptData(base64, encryptionKey);
                        isEncrypted = true;
                    } catch (error) {
                        console.error('Fehler bei Datenverschlusselung:', error);
                        showStatus('Fehler bei Verschlüsselung: ' + error.message, 'error');
                        throw error;
                    }
                }

                // last_local_change vom Client ermitteln
                let lastLocalChange = null;
                try {
                    const result = db.exec(`
                        SELECT value FROM metadata WHERE key = 'last_local_change'
                    `);
                    if (result.length > 0 && result[0].values.length > 0) {
                        lastLocalChange = result[0].values[0][0];
                    }
                } catch (e) {
                    console.warn('Konnte last_local_change nicht laden:', e.message);
                }

                return {
                    data: base64,
                    timestamp: timestamp,
                    last_local_change: lastLocalChange, // Zum Server schicken
                    deviceFingerprint: getDeviceFingerprint(), // Geräte-Fingerprint hinzufügen
                    version: APP_VERSION,
                    encrypted: isEncrypted // Markiere ob verschlüsselt
                };
            } catch (error) {
                console.error('Fehler beim Serialisieren der Datenbank:', error);
                throw error;
            }
        }

        // Hilfsfunktion: Datenbank aus JSON deserialisieren
        async function deserializeDatabaseFromJSON(jsonData) {
            try {
                let base64Data = jsonData.data;

                // Prüfen, ob Daten verschlüsselt sind
                if (jsonData.encrypted) {
                    const encryptionKey = getEncryptionKey();
                    if (!encryptionKey) {
                        throw new Error('Verschlüsselte Daten gefunden, aber kein Key konfiguriert');
                    }

                    try {
                        // Entschlüsseln vor Base64-Dekodierung
                        base64Data = await decryptData(base64Data, encryptionKey);
                    } catch (error) {
                        console.error('Fehler bei Entschlüsselung:', error);
                        throw new Error('Daten konnten nicht entschlüsselt werden. Möglicherweise falscher Verschlüsselungs-Schlüssel.');
                    }
                }

                const arrayBuffer = base64ToArrayBuffer(base64Data);

                // Neue Datenbank erstellen und laden
                const newDb = new SQL.Database(new Uint8Array(arrayBuffer));

                // Datenbank-Tabellen verifizieren
                const tables = newDb.exec(`
                    SELECT name FROM sqlite_master
                    WHERE type='table' AND name IN ('events', 'tasks', 'completed_tasks', 'metadata', 'calendar_todos')
                `);

                if (tables.length === 0 || tables[0].values.length < 4) {
                    throw new Error('Ungültige Datenbankstruktur in heruntergeladenen Daten');
                }

                return {
                    db: newDb,
                    timestamp: jsonData.timestamp,
                    version: jsonData.version
                };
            } catch (error) {
                console.error('Fehler beim Deserialisieren der Datenbank:', error);
                throw error;
            }
        }

        // Datenbank zum Server hochladen
        async function uploadDatabaseToServer() {
            const config = getServerConfig();
            if (!config) return;

            try {
                showStatus('Lade Datenbank zum Server hoch...', 'info');

                const jsonData = await serializeDatabaseAsJSON();
                const payload = {
                    action: 'upload',
                    uid: config.uid,
                    data: jsonData
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Sync-Zeitpunkt aktualisieren und lokale Änderungszeit zurücksetzen
                    const now = new Date().toISOString();
                    

                    db.run(`
                        INSERT OR REPLACE INTO metadata (key, value, updated_at)
                        VALUES ('last_sync_time', ?, datetime('now'))
                    `, [now]);

                    db.run(`
                        INSERT OR REPLACE INTO metadata (key, value, updated_at)
                        VALUES ('last_local_change', ?, datetime('now'))
                    `, [now]);

                    saveDatabase();
                    

                    showStatus('Datenbank erfolgreich zum Server hochgeladen', 'success');
                } else {
                    throw new Error(result.message || 'Unbekannter Fehler beim Upload');
                }

            } catch (error) {
                console.error('Fehler beim Hochladen:', error);
                showStatus(`Fehler beim Hochladen: ${error.message}`, 'error');
            }
        }

        // Datenbank vom Server herunterladen
        async function downloadDatabaseFromServer(skipConfirmation = false) {
            const config = getServerConfig();
            if (!config) return;

            try {
                showStatus('Lade Datenbank vom Server herunter...', 'info');

                const payload = {
                    action: 'download',
                    uid: config.uid
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.success) {
                    if (result.data) {
                        // Lokale Datenbank mit Server-Daten ersetzen
                        const serverData = await deserializeDatabaseFromJSON(result.data);

                        // Sicherheitsfrage vor Überschreiben (nur wenn nicht deaktiviert)
                        if (!skipConfirmation) {
                            const confirmed = await customConfirm(
                                `Möchtest du die lokale Datenbank wirklich mit den Server-Daten vom ${new Date(serverData.timestamp).toLocaleString()} ersetzen?` +
                                `\n\nLokale Änderungen könnten verloren gehen.`,
                                "Server-Daten übernehmen"
                            );

                            if (!confirmed) {
                                // NEU: Deaktiviere weitere automatische Nachfragen für 5 Minuten
                                syncSuggestionDisabledUntil = Date.now() + DISABLE_DURATION_MS;
                                showStatus('Download abgebrochen. Weitere automatische Nachfragen werden 5 Minuten ausgesetzt.', 'info');
                                return;
                            }
                        }

                        // Datenbank ersetzen
                        db = serverData.db;

                        // Datenbank speichern und neu laden
                        saveDatabase();

                        // Neu laden der aktuellen Ansicht
                        loadEvents();
                        loadTodos();
                        loadTasks();

                        // Sync-Zeitpunkt aktualisieren und lokale Änderungszeit mit Server synchronisieren
                        const now = new Date().toISOString();
                        

                        db.run(`
                            INSERT OR REPLACE INTO metadata (key, value, updated_at)
                            VALUES ('last_sync_time', ?, datetime('now'))
                        `, [now]);

                        // Lokale Änderungszeit auf Server-Zeit setzen (da Server Daten haben Vorrang)
                        db.run(`
                            INSERT OR REPLACE INTO metadata (key, value, updated_at)
                            VALUES ('last_local_change', ?, datetime('now'))
                        `, [now]);
                        saveDatabase();
                        

                        showStatus(`Datenbank erfolgreich vom Server heruntergeladen (${serverData.timestamp})`, 'success');

                    } else {
                        showStatus('Keine Daten auf dem Server gefunden', 'warning');
                    }
                } else {
                    throw new Error(result.message || 'Unbekannter Fehler beim Download');
                }

            } catch (error) {
                console.error('Fehler beim Herunterladen:', error);
                showStatus(`Fehler beim Herunterladen: ${error.message}`, 'error');
            }
        }

        // ============================
        // MODAL CLOSE EVENT-LISTENER
        // ============================

        // Modal schließende X-Buttons
        document.querySelectorAll('#serverConfigModal .close').forEach(close => {
            close.addEventListener('click', closeServerConfigModal);
        });

        // Modal außerhalb klicken schließt es
        document.getElementById('serverConfigModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('serverConfigModal')) {
                closeServerConfigModal();
            }
        });

        // Backup-Versionen Event-Listener
        document.getElementById('backupVersionsBtn').addEventListener('click', (e) => {
            e.preventDefault();
            openBackupVersionsModal();
        });

        document.getElementById('backupVersionsModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('backupVersionsModal')) {
                closeBackupVersionsModal();
            }
        });

        document.getElementById('backupVersionsModal').querySelector('.close').addEventListener('click', closeBackupVersionsModal);

        document.getElementById('closeVersionsBtn').addEventListener('click', closeBackupVersionsModal);

        // ============================
        // BACKUP-VERSIONEN FUNKTIONEN
        // ============================

        // Backup-Versionen Modal öffnen
        function openBackupVersionsModal() {
            const config = getServerConfig();
            if (!config) {
                alert('Bitte zuerst Server-Konfiguration einrichten.');
                openServerConfigModal();
                return;
            }

            // SYNK-STATUS: Serverstatus vor Öffnen des Backup/Versions-Modals aktualisieren
            updateSyncIndicator();

            document.getElementById('backupVersionsModal').style.display = 'flex';

            // Liste automatisch laden
            loadBackupVersions();
        }

        // Backup-Versionen Modal schließen
        function closeBackupVersionsModal() {
            document.getElementById('backupVersionsModal').style.display = 'none';
            document.getElementById('versionsList').innerHTML = '';
        }

        // Backup-Versionen vom Server laden
        async function loadBackupVersions() {
            const config = getServerConfig();
            if (!config) {
                alert('Keine Server-Konfiguration gefunden.');
                return;
            }

            try {
                showStatus('Lade Backup-Versionen...', 'info');

                const payload = {
                    action: 'list_versions',
                    uid: config.uid
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    displayVersions(result.versions);
                    showStatus(`${result.versions.length} Backup-Versionen gefunden`, 'success');
                } else {
                    throw new Error(result.message || 'Unbekannter Fehler');
                }

            } catch (error) {
                console.error('Fehler beim Laden der Versionen:', error);
                document.getElementById('versionsList').innerHTML = `<p style="color: red;">Fehler: ${error.message}</p>`;
                showStatus(`Fehler beim Laden der Versionen: ${error.message}`, 'error');
            }
        }

        // Backup-Versionen anzeigen
        function displayVersions(versions) {
            const versionsListDiv = document.getElementById('versionsList');

            if (versions.length === 0) {
                versionsListDiv.innerHTML = '<p>Keine Backup-Versionen found.</p>';
                return;
            }

            let html = '<table><thead><tr><th>Version</th><th>Hochgeladen</th><th>Status</th><th>Aktion</th></tr></thead><tbody>';

            versions.forEach(version => {
                const isCurrent = version.is_current ? ' (Aktuell)' : '';
                const statusBadge = version.is_current ? '<span style="color: green; font-weight: bold;">aktuell</span>' :
                                  '<span style="color: blue;">archiviert</span>';

                html += `<tr>
                    <td>${version.filename}<br><small style="color: #666;">Gerät: ${version.deviceFingerprint || 'Unbekannt'}</small></td>
                    <td>${new Date(version.uploaded_at).toLocaleString()}</td>
                    <td>${statusBadge}</td>
                    <td>
                        ${version.is_current ? '<em>aktuelle Serverversion</em>' :
                          `<div style="display:flex; flex-direction:column; gap:5px;">
                            <button class="btn btn-secondary btn-sm" style="width:100%;" onclick="confirmRestoreVersion('${version.filename}')">Wiederherstellen</button>
                            <button class="btn btn-danger btn-sm" style="width:100%;" onclick="confirmDeleteVersion('${version.filename}')">Löschen</button>
                          </div>`}
                    </td>
                </tr>`;
            });

            html += '</tbody></table>';
            versionsListDiv.innerHTML = html;
        }

        // Version Wiederherstellen bestätigen
        async function confirmRestoreVersion(filename) {
            const confirmed = await customConfirm(
                `Möchtest du die Version "${filename}" wirklich wiederherstellen?\n\nDie aktuelle Datenbank wird durch diese Backup-Version ersetzt.`,
                "Backup-Version wiederherstellen"
            );

            if (confirmed) {
                await restoreBackupVersion(filename);
            }
        }

        // Backup-Version wiederherstellen
        async function restoreBackupVersion(filename) {
            const config = getServerConfig();
            if (!config) {
                alert('Keine Server-Konfiguration gefunden.');
                return;
            }

            try {
                showStatus('Stelle Backup-Version wieder her...', 'info');

                const payload = {
                    action: 'restore_version',
                    uid: config.uid,
                    filename: filename
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // Neue aktuelle Daten vom Server laden (ohne zusätzliche Bestätigung)
                    await downloadDatabaseFromServer(true);
                    closeBackupVersionsModal();
                    showStatus('Backup-Version erfolgreich wiederhergestellt', 'success');
                } else {
                    throw new Error(result.message || 'Unbekannter Fehler');
                }

            } catch (error) {
                console.error('Fehler beim Wiederherstellen der Version:', error);
                showStatus(`Fehler beim Wiederherstellen: ${error.message}`, 'error');
            }
        }

        // Version löschen bestätigen
        async function confirmDeleteVersion(filename) {
            const confirmed = await customConfirm(
                `Möchtest du die Version "${filename}" wirklich unwiderruflich löschen?`,
                "Backup-Version löschen"
            );

            if (confirmed) {
                await deleteBackupVersion(filename);
            }
        }

        // Backup-Version löschen
        async function deleteBackupVersion(filename) {
            const config = getServerConfig();
            if (!config) {
                alert('Keine Server-Konfiguration gefunden.');
                return;
            }

            try {
                showStatus('Lösche Backup-Version...', 'info');

                const payload = {
                    action: 'delete_version',
                    uid: config.uid,
                    filename: filename
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    closeBackupVersionsModal();
                    showStatus('Backup-Version erfolgreich gelöscht', 'success');
                    // Liste neu laden
                    openBackupVersionsModal();
                } else {
                    throw new Error(result.message || 'Unbekannter Fehler');
                }

            } catch (error) {
                console.error('Fehler beim Löschen der Version:', error);
                showStatus(`Fehler beim Löschen: ${error.message}`, 'error');
            }
        }

        // ============
        // CONTACT FUNKTIONEN (FEHLTE IN PREVIOUS APPEND)
        // ============

        // Contact-Modal öffnen
        function openContactModal() {
            document.getElementById('contactModal').style.display = 'flex';
        }

        // Contact-Form senden
        async function sendContactForm(e) {
            e.preventDefault();

            const name = document.getElementById('contactName').value.trim();
            const email = document.getElementById('contactEmail').value.trim();
            const message = document.getElementById('contactText').value.trim();

            // Basis-Validierung
            if (!name || !email || !message) {
                showStatus('Bitte fülle alle Felder aus', 'error');
                return;
            }

            const config = getServerConfig();
            if (!config) {
                showStatus('Kontaktformular erfordert Server-Konfiguration', 'error');
                return;
            }

            try {
                showStatus('Sende Nachricht...', 'info');

                const payload = {
                    action: 'send_mail',
                    uid: config.uid,
                    name: name,
                    email: email,
                    message: message
                };

                const response = await fetch(config.url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    showStatus('Nachricht erfolgreich gesendet', 'success');
                    document.getElementById('contactForm').reset();
                    document.getElementById('contactModal').style.display = 'none';
                } else {
                    showStatus(result.message || 'Fehler beim Senden der Nachricht', 'error');
                }

            } catch (error) {
                console.error('Fehler beim Senden der Kontakt-Nachricht:', error);
                showStatus('Fehler beim Senden der Nachricht: ' + error.message, 'error');
            }
        }

        // ============================
        // TEST-FUNKTIONEN FÜR VERSCHLÜSSELUNG
        // ============================

        // Test der Verschlüsselung/Entschlüsselung
        async function testEncryption() {
            try {
                const testKey = 'meinTestPasswort123';
                const testData = 'Hello, verschlüsselte Welt!';
                console.log('=== Verschlüsselungs-Test ===');
                console.log('Original-Daten:', testData);

                // Verschlüsseln
                const encrypted = await encryptData(testData, testKey);
                console.log('Verschlüsselte Daten:', encrypted);

                // Entschlüsseln
                const decrypted = await decryptData(encrypted, testKey);
                console.log('Entschlüsselte Daten:', decrypted);

                // Prüfen ob identisch
                if (testData === decrypted) {
                    console.log('✅ Verschlüsselung/Entschlüsselung erfolgreich!');
                    return true;
                } else {
                    console.error('❌ Daten stimmen nicht überein!');
                    return false;
                }
            } catch (error) {
                console.error('❌ Verschlüsselungs-Test fehlgeschlagen:', error);
                return false;
            }
        }

        // Test der Datenbank-Serialisierung mit Verschlüsselung
        async function testDatabaseSerialization() {
            try {
                console.log('=== Datenbank-Serialisierung-Test ===');

                // Konfiguration setzen für Test
                db.run(`INSERT OR REPLACE INTO metadata (key, value, updated_at) VALUES ('encryption_key', 'testkey123', datetime('now'))`);

                // Serialisierung testen
                const serialized = await serializeDatabaseAsJSON();
                console.log('Serialisierte Daten enthalten Verschlüsselung:', serialized.encrypted);

                // Deserialisierung testen
                const deserialized = await deserializeDatabaseFromJSON(serialized);
                console.log('✅ Datenbank-Serialisierung/Deserialisierung erfolgreich!');

                // Test-Key zurücksetzen
                db.run(`DELETE FROM metadata WHERE key = 'encryption_key'`);

                return true;
            } catch (error) {
                console.error('❌ Datenbank-Serialisierung-Test fehlgeschlagen:', error);
                return false;
            }
        }

        // Alle Tests ausführen (im Browser-Konsole aufrufen)
        async function runAllTests() {
            console.log('=== STARTE INTEGRATIONSTESTS FÜR VERSCHLÜSSELUNG ===');

            let encryptionTest = false;
            let serializationTest = false;

            try {
                if (db) {
                    encryptionTest = await testEncryption();
                    serializationTest = await testDatabaseSerialization();
                } else {
                    console.warn('⚠️ Datenbank nicht verfügbar - überspringe Tests');
                }
            } catch (error) {
                console.error('❌ Fehler beim Testen:', error);
            }

            console.log('\n=== TESTERGEBNIS ===');
            console.log('• Verschlüsselung:', encryptionTest ? '✅ Erfolgreich' : '❌ Fehlgeschlagen');
            console.log('• Datenbank-Serialisierung:', serializationTest ? '✅ Erfolgreich' : '❌ Fehlgeschlagen');

            if (encryptionTest && serializationTest) {
                console.log('🎉 Alle Tests erfolgreich bestanden!');
            }
        }

        // Konsolen-Befehle für Tests:
        // runAllTests() - Führt alle Tests aus
        // testEncryption() - Testet nur Verschlüsselung
        // testDatabaseSerialization() - Testet nur Datenbank-Serialisierung

    </script>
</body>
</html>
